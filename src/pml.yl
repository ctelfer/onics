/*
?- tcp.sport == tcp.ports.http -?

?- ip.saddr == 127.0.0.0/24 -?

?- eth && ip6 && pkt.len > ip6.len + 40 + 14 -?

?- pop(tcp.flags) == 2 -?

?- nlz(ip6.flowid) == 4 -?

?- eth.saddr =/ c0:2a:f9:00:00:00/ff:ff:ff:f0:00:00 -?
?- eth.saddr !/ c0:2a:f9:00:00:00/ff:ff:ff:f0:00:00 -?  

?- not (pkt.data =~ "hello +world!") -?
?- not (pkt.data !~ "hello +world!") -?

?- tcp.dport == tcp.ports.reserved -?

?- uint(tcp[2:2]) == 1628 -?

?- tcp[2:10] == \xABCDEF0123DEADBEEF01/FEEDA110FFFFFFFFAB -?

?- ip:1[3:1] == "a" -?


?- eth.saddr == 5 -? # error
*/


/* 
  Actions:

  Drop
  Insert space
  Cut space
  Duplicate
  Push header
  Fix lengths
  Fix checksum
  Fix dlt
  Enqueue packet
  Set field/variable
  Fun call 
  Print
  Return

  if () { 
  }

  while () { 
  }


  Declarations:
  function name ( arg1, arg2 ... ) {
    <local variable declarations here>

    <action list>
    
    return(v1, v2, ...);
  }

  var name;
  var name[width];
*/

/* ----- Basic Lemon Declarations ----- */

%name PML
%token_prefix PMLTOK_
%include { 
#include <cat/cat.h>
#include <cat/list.h>
#include "pmltree.h" 
#include "pmllex.h"
}
%extra_argument { struct pml_ast *ast }

/* ----- Mappings between non-terminals and C types ----- */

%type decl { union pml_tree * }
%destructor decl { pmlt_free($$); }

%type rule { struct pml_rule * }
%destructor rule { pmlt_free($$); }

%type pktpat { struct pml_expr_u * }
%destructor pktpat { pmlt_free($$); }

%type expr { union pml_expr_u * }
%destructor expr { pmlt_free($$); }

%type stmt { union pml_tree * }
%destructor stmt { pmlt_free($$); }

%type stmtlist { struct pml_list * }
%destructor stmtlist { pmlt_free($$); }

%type stmts { struct pml_list * }
%destructor stmts { pmlt_free($$); }

%type pktact { struct pml_pkt_action * }
%destructor pktact { pmlt_free($$); }

%type var { struct pml_locator * }
%destructor var { pmlt_free($$); }

%type exprlist { struct pml_list * }
%destructor exprlist { pmlt_free($$); }

%type pktoff { struct pml_locator * }
%destructor pktoff { pmlt_free($$); }

%type locator { struct pml_locator * }
%destructor locator { pmlt_free($$); }

%type idlist { struct pml_list * }
%destructor idlist { pmlt_free($$); }

%type type { int }

%type orexpr { struct pml_binop * } 
%destructor orexpr { pmlt_free($$); }

%type andexpr { struct pml_binop * } 
%destructor andexpr { pmlt_free($$); }

%type cmpexpr { struct pml_binop * } 
%destructor cmpexpr { pmlt_free($$); }

%type maskop { int }
%type cmpop  { int }

%type borexpr { struct pml_binop * } 
%destructor borexpr { pmlt_free($$); }

%type bxorexpr { struct pml_binop * } 
%destructor bxorexpr { pmlt_free($$); }

%type bandexpr { struct pml_binop * } 
%destructor bandexpr { pmlt_free($$); }

%type addexpr { struct pml_binop * } 
%destructor addexpr { pmlt_free($$); }

%type mulexpr { struct pml_binop * } 
%destructor mulexpr { pmlt_free($$); }

%type shiftexpr { struct pml_binop * } 
%destructor shiftexpr { pmlt_free($$); }

%type shiftop { int }

%type uexpr { struct pml_unop * } 
%destructor uexpr { pmlt_free($$); }

%type valexpr { struct pml_value * } 
%destructor valexpr { pmlt_free($$); }

%type intrinsic { int }

%type field { union pml_field_u * } 
%destructor field { pmlt_free($$); }

%token_type { struct pml_lex_val }
%token_destructor { 
	if ($$.type == PMLLV_STRING) {
		free($$.u.raw.data);
		$$.u.raw.data = NULL;
	}
}

/* ----- Grammar ----- */

prog ::= decllist.

/* Declarations */
decllist ::= decllist decl(A). { 
	struct pml_node *n = A->pml_node;
	if (n->pmln_type == PMLTT_FUNCION) {
		/* TODO */
	} else if (n->pmln_type == PMLTT_VARREF) {
		/* TODO */
	} else {
		abort_unless(0);
	}
}

decllist ::= decllist rule(A). {
	l_ins(&ast->pmla_rules.prev, &A->pml_node->pmln_ln);
}

decllist ::= .


/* Rules */
rule(R) ::= pktpat(P) stmt(S). {
	struct pml_list *l = (struct pml_list *)pmlt_alloc(PMLTT_LIST);
	R = (struct pml_rule *)pmlt_alloc(PMLTT_RULE);
	l_ins(&l->pmll_list, &S->pmlt_node->pmln_ln);
	R->pmlr_pattern = P;
	R->pmlr_stmts = l;
}
rule(R) ::= pktpat(P) stmtlist(SL). {
	R = (struct pml_rule *)pmlt_alloc(PMLTT_RULE);
	R->pmlr_pattern = P;
	R->pmlr_stmts = SL;
}

/* Statements */
stmtlist(SL) ::= LBRACE stmts(SS) RBRACE. { SL = SS; }

stmts(SS) ::= stmt(S) SEMICOLON. {
	struct pml_list *l = (struct pml_list *)pmlt_alloc(PMLTT_LIST);
	l_ins(&l->pmll_list, &S->pmlt_node->pmln_ln);
	SS = l;
}
stmts(SSO) ::= stmts(SSI) stmt(S) SEMICOLON. {
	l_ins(&SSI->pmll_list, &S->pmlt_node->pmln_ln);
	SSO = SSI;
}


/* Specific types of statements */
stmt(S) ::= pktact(PA). { S = (union pml_tree *)PA; }

stmt(S) ::= var(V) ASSIGN expr(E). {
	struct pml_set_action *a = 
		(struct plm_set_action *)pmlt_alloc(PMLTT_SETACT);
	a->pmlsa_variable = V;
	a->pmlsa_expr = E;
	S = (union pml_tree *)a;
}

stmt(S) ::= WHILE LPAREN expr(E) RPAREN stmtlist(SL). {
	struct pml_while *w = (struct pml_while *)pmlt_alloc(PMLTT_WHILE);
	w->pmlw_test = E;
	w->pmlw_body = SL;
	S = (union pml_tree *)w;
}

stmt(S) ::= IF LPAREN expr(E) RPAREN stmtlist(SL). {
	struct pml_if *i = (struct pml_if *)pmlt_alloc(PMLTT_IF);
	i->pmlif_test = E;
	i->pmlif_tbody = SL;
	S = (union pml_tree *)i;
}

stmt(S) ::= IF LPAREN expr(E) RPAREN stmtlist(SLT) ELSE stmtlist(SLF). {
	struct pml_if *i = (struct pml_if *)pmlt_alloc(PMLTT_IF);
	i->pmlif_test = E;
	i->pmlif_tbody = SLT;
	i->pmlif_fbody = SLF;
	S = (union pml_tree *)i;
}

stmt(S) ::= RETURN expr(E).  {
	struct pml_return *r = (struct pml_return *)pmlt_alloc(PMLTT_RETURN);
	r->pmlret_expr = E;
	S = (union pml_tree *)r;
}

stmt(S) ::= PRINT STRING(TV). {
	struct pml_print *p = (struct pml_print *)pmlt_alloc(PMLTT_PRINT);
	p->pmlp_fmt = TV.u.raw.data;
	S = (union pml_tree *)p;
}

stmt(S) ::= PRINT STRING(TV) COMMA exprlist(EL). {
	struct pml_print *p = (struct pml_print *)pmlt_alloc(PMLTT_PRINT);
	p->pmlp_fmt = TV.u.raw.data;
	p->pmlp_args = EL;
	S = (union pml_tree *)p;
}


pktact ::= DROP.
pktact ::= DROP ID.
pktact ::= INSERT pktoff expr.
pktact ::= CUT pktoff expr.
pktact ::= DUP NUM.
pktact ::= DUP ID NUM.
pktact ::= FIXLEN.
pktact ::= FIXLEN locator.
pktact ::= FIXCSUM locator.
pktact ::= FIXDLT locator.
pktact ::= ENQUEUE ID.


decl ::= funcdecl.
decl ::= vardecl.

funcdecl ::= DEF ID LPAREN idlist RPAREN LBRACE vardecls stmts RBRACE.
idlist ::= .
idlist ::= someids.
someids ::= ID.
someids ::= someids COMMA ID.

vardecl ::= type ID SEMICOLON.
vardecl ::= type ID LBRACKET NUM RBRACKET.
vardecls ::= .
vardecls ::= vardecls vardecl.

pktpat ::= PPBEGIN expr PPEND.

expr ::= orexpr.

orexpr ::= orexpr OR andexpr.
orexpr ::= andexpr.

andexpr ::= andexpr AND cmpexpr.
andexpr ::= cmpexpr.

cmpexpr ::= BYTESTR REX STRING.
cmpexpr ::= BYTESTR NOTREX STRING.
cmpexpr ::= borexpr cmpop borexpr.
cmpexpr ::= borexpr maskop BYTESTR DIV BYTESTR.
cmpexpr ::= borexpr maskop IPV4ADDR DIV NUM.
cmpexpr ::= borexpr maskop IPV6ADDR DIV NUM.
cmpexpr ::= borexpr maskop ETHADDR DIV ETHADDR.
cmpexpr ::= borexpr.

maskop ::= MASKEQ.
maskop ::= MASKNE.

cmpop ::= EQ.
cmpop ::= NEQ.
cmpop ::= LT.
cmpop ::= GT.
cmpop ::= LEQ.
cmpop ::= GEQ.

borexpr ::= borexpr BOR bxorexpr.
borexpr ::= bxorexpr.

bxorexpr ::= bxorexpr BXOR bandexpr.
bxorexpr ::= bandexpr.

bandexpr ::= bandexpr BAND addexpr.
bandexpr ::= addexpr.

addexpr ::= addexpr PLUS mulexpr.
addexpr ::= addexpr MINUS mulexpr.
addexpr ::= mulexpr.

mulexpr ::= mulexpr TIMES shiftexpr.
mulexpr ::= mulexpr DIV shiftexpr.
mulexpr ::= mulexpr MOD shiftexpr.
mulexpr ::= shiftexpr.

shiftexpr ::= shiftexpr shiftop uexpr.
shiftexpr ::= uexpr.

shiftop ::= SHL.
shiftop ::= SHR.
shiftop ::= SHRA.

uexpr ::= NOT valexpr.
uexpr ::= BINV valexpr.
uexpr ::= MINUS valexpr.
uexpr ::= valexpr.

valexpr ::= LPAREN expr RPAREN.
valexpr ::= intrinsic LPAREN expr RPAREN.
valexpr ::= funcall.
valexpr ::= field.

intrinsic ::= POP.
intrinsic ::= NLZ.
intrinsic ::= type.

type ::= UINT8.
type ::= INT8.
type ::= UINT16.
type ::= INT16.
type ::= UINT32.
type ::= INT32.

funcall ::= ID LPAREN exprlist RPAREN.
funcall ::= ID LPAREN RPAREN.

exprlist ::= exprlist COMMA expr.
exprlist ::= expr.

field ::= var.
field ::= BYTESTR.
field ::= IPADDR.
field ::= IPV6ADDR.
field ::= NUM.
field ::= STRING.

var ::= locator.
var ::= locator LBRACKET borexpr COLON borexpr RBRACKET.

locator ::= locator DOT ID.
locator ::= ID.

pktoff ::= locator.
pktoff ::= locator LBRACKET borexpr RBRACKET.

