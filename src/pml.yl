/*


# Comment 

?- tcp.sport == tcp.ports.http -?

# Match operator is =~, inverse is !~
# Takes field on one side, pattern other
# Patterns include:
#   IP[v6] w/ mask, bytestring w/ mask, eth addr w/ mask,
#   regex, numeric range
#
?- ip.saddr =~ 127.0.0.0/24 -?          # IP w/mask
?- eth.saddr !~ c0:2a:f9:00:00:00/ff:ff:ff:f0:00:00 -?  # eth addr
?- not (pkt.data =~ "hello world!") -?  # ascii string match
?- not (pkt.data !~ \xa5a6a7a8a9aaabac) -?  # byte string match 
?- pkt.data =~ `hello +world!` -?       # regex
?- ipv6.daddr =~ ff80:abcd::/8 -?	# ipv6 w/mask
?- tcp.dport !~ tcp.ports.reserved -?   # numeric range
?- udp.sport !~ [0..1023] -?		# numeric range
?- tcp[2,10] =~ \xABCDEF0123DEADBEEF01/FEEDA110FFFFFFFFAB -? # bytes w/ mask

# Short circuiting boolean ops are supported of course
?- eth && ip6 && pkt.len > ip6.len + 40 + 14 -?

?- pop(tcp.flags == 2) -?

?- nlz(ip6.flowid) == 4 -?

?- tcp[2,2] == 1628 -?

# second IP header in the first packet
?- ip[3,1] == 65 -?

# compares as 64-bit integer
?- eth.saddr == 5 -? 

# compares first 8 bytes as 64-bit integer
# probably not intended 
?- ipv6.saddr == 5 -? 

# A inline function that calls only other inline functions and is not
# directly or indirectly recursive.
inline ishttp() ( tcp && (tcp.sport == 80 || tcp.dport == 80) )

# A function can be recursive, have local variables and it has
# a series of statements enclosed in parentheses.
func incr(v) {
	x = v + 1;
	return x;
}
var Count;

# Patterns can call inline functions.
?- ishttp() -? { Count = incr(Count); }

*/


/* 

  Variables -- local all variables are 32 bit numbers (for now); will add more
               types later.  (8, 16, 32, 64-bit signed and unsigned, plus 
               bytestrings)
  Local variables are referred to by name
  

  Abstractions:
   - PRID == protocol ID, identifies a parsable protocol
   - PKID == packet ID, identifies one of the 16 packets in the working set
   - FLD == field, a unit of data that has meaning within a protocol
            There are 2 data types of fields:
	      - bit fields - width <= 32 bits and do not start at byte offsets
	      - byte string - Starts at a byte offset, and can have any width.
	            data within the field can be interpreted in any desired
		    way.
		    * byte strings of 8 or less bytes can be operated on as
		      numeric values.

	    There are 3 special field access characteristics
	      - Required -- cannot be unset  (e.g. start offset)
	      - Derived position -- cannot be unset and offset does not move 
	          with an 'insert' or 'cut' unless the offset(s) it depends
		  upon also move.
	      - Derived value -- cannot be set or unset, field is not present
	          in the data explicitly, but derived from offsets or other
		  fields in the data.

  Notation:
   a			-- Variable name (global or local) or proto name
   @@<protoname>	-- Protocol ID 
   a.b.c.d		-- Field for packet 0 or protocol constant
   a.b.c.d[o,l]		-- Bytes from packet 0, field a.b.c.d, offset o length l
   @a{p}.b.c.d[o,l]	-- Bytes from packet p, field a.b.c.d, offset o length l
   @a{p,i}.b.c.d[o,l]	-- Bytes from packet p, field a.b.c.d, offset o length l
   &<field>		-- Byte offset for a field <byte string or integer>


  Intrinsic Functions:
   - Drop
   - Fix dlt
   - Insert space
   - Cut space
   - Duplicate
   - Push header inner or outer
   - Pop header inner or outer
   - Update header
   - Fix lengths
   - Fix checksum
   - Enqueue packet
   - Dequeue packet
   - Send packet queue
   - (Un)Set layer
   - pop(ulation count)
   - nlz (number of leading zeroes)
   - signext (sign extend a value)

  Statements: 
   - Any expression (including function calls)
   - if then else
   - while
   - Set field/variable
   - Print
   - Return


  Example:
	insert(10, &tcp + 20); # insert 10 bytes of data 20-bytes 
                               # after the TCP section start
	insert(4, &net + 20, 20);
	cut(10, &ip + ip.hl * 4);
	fixcsum();

  if () { 
  }

  while () { 
  }


  Declarations:
  function name ( arg1, arg2 ... ) {
    <local variable declarations here>

    <action list>
    
    return(v1, v2, ...);
  }

  var name;
  var name = <scalar value>;
  var name[width]; # global only
  var name[width] = <value>; # global only
*/

/* 
 * ----- TODO: -----
 * Proper return value checking for pmln_alloc();
 * ----------------- 
 */


/* ----- Basic Lemon Declarations ----- */

%name PML
%token_prefix PMLTOK_
%include { 
#include <string.h>
#include <stdlib.h>
#include <assert.h>  /* XXX needed by lemon */
#include <cat/cat.h>
#include <cat/list.h>
#include "pmltree.h" 
#include "ns.h"
}
%extra_argument { struct pml_ast *ast }

%syntax_error {
	pml_ast_err(ast, "syntax error");
	ast->error = 1;
}

%parse_failure {
	pml_ast_err(ast, "parse error");
	ast->error = 1;
}

%parse_accept {
	ast->done = 1;
}

/* ----- Mappings between non-terminals and C types ----- */

%type decl { union pml_node * }
%destructor decl { pmln_free($$); }

%type funcdecl { struct pml_function * }
%destructor funcdecl { pmln_free((union pml_node *)$$); }

%type inlinedecl { struct pml_function * }
%destructor inlinedecl { pmln_free((union pml_node *)$$); }

%type gvar { struct pml_variable * }
%destructor gvar { pmln_free((union pml_node *)$$); }

%type rule { struct pml_rule * }
%destructor rule { pmln_free((union pml_node *)$$); }

%type pktpat { union pml_expr_u * }
%destructor pktpat { pmln_free((union pml_node *)$$); }

%type expr { union pml_expr_u * }
%destructor expr { pmln_free((union pml_node *)$$); }

%type stmt { union pml_node * }
%destructor stmt { pmln_free($$); }

%type stmtlist { struct pml_list * }
%destructor stmtlist { pmln_free((union pml_node *)$$); }

%type stmts { struct pml_list * }
%destructor stmts { pmln_free((union pml_node *)$$); }

%type locator { struct pml_locator * }
%destructor locator { pmln_free((union pml_node *)$$); }

%type exprlist { struct pml_list * }
%destructor exprlist { pmln_free((union pml_node *)$$); }

%type locname { struct pml_locator * }
%destructor locname { pmln_free((union pml_node *)$$); }

%type locstr { struct pml_locator * }
%destructor locstr { pmln_free((union pml_node *)$$); }

%type pktname { struct pml_locator * }
%destructor pktname { pmln_free((union pml_node *)$$); }

%type idlist { struct pml_list * }
%destructor idlist { pmln_free((union pml_node *)$$); }

%type someids { struct pml_list * }
%destructor someids { pmln_free((union pml_node *)$$); }

%type type { int }

%type cfmkw { int }

%type orexpr { union pml_expr_u * } 
%destructor orexpr { pmln_free((union pml_node *)$$); }

%type andexpr { union pml_expr_u * } 
%destructor andexpr { pmln_free((union pml_node *)$$); }

%type cmpexpr { union pml_expr_u * } 
%destructor cmpexpr { pmln_free((union pml_node *)$$); }

%type matchop { int }
%type cmpop  { int }

%type borexpr { union pml_expr_u * } 
%destructor borexpr { pmln_free((union pml_node *)$$); }

%type bxorexpr { union pml_expr_u * } 
%destructor bxorexpr { pmln_free((union pml_node *)$$); }

%type bandexpr { union pml_expr_u * } 
%destructor bandexpr { pmln_free((union pml_node *)$$); }

%type addexpr { union pml_expr_u * } 
%destructor addexpr { pmln_free((union pml_node *)$$); }

%type mulexpr { union pml_expr_u * } 
%destructor mulexpr { pmln_free((union pml_node *)$$); }

%type shiftexpr { union pml_expr_u * } 
%destructor shiftexpr { pmln_free((union pml_node *)$$); }

%type shiftop { int }

%type uexpr { union pml_expr_u * } 
%destructor uexpr { pmln_free((union pml_node *)$$); }

%type pexpr { union pml_expr_u * } 
%destructor pexpr { pmln_free((union pml_node *)$$); }

%type valexpr { union pml_expr_u * } 
%destructor valexpr { pmln_free((union pml_node *)$$); }

%type value { union pml_expr_u * } 
%destructor value { pmln_free((union pml_node *)$$); }

%type call { struct pml_call * } 
%destructor call { pmln_free((union pml_node *)$$); }

%type numval { struct pml_literal * }
%destructor numval { pmln_free((union pml_node *)$$); }

%token_type { struct pml_lex_val }
%token_destructor { 
	pml_lexv_fini(yymajor, &$$);
}

/* ----- Grammar ----- */

prog ::= decllist. {
	pml_ast_finalize(ast);
}

/* Declarations */
decllist ::= decllist decl. /* nothing to do: resolved below. */

decllist ::= . /* nothing to do */

decl ::= funcdecl(F). {
	if (pml_ast_add_func(ast, F) < 0)
		pmln_free((union pml_node *)F);
}
decl ::= inlinedecl(F). {
	if (pml_ast_add_func(ast, F) < 0)
		pmln_free((union pml_node *)F);
}
decl ::= gvar(V). {
	if (pml_ast_add_var(ast, V) < 0)
		pmln_free((union pml_node *)V);
}
decl ::= rule(R). {
	if (pml_ast_add_rule(ast, R) < 0)
		pmln_free((union pml_node *)R);
}

type(T) ::= INT. { T = PML_ETYPE_SCALAR; }
type(T) ::= VOID. { T = PML_ETYPE_VOID; }

funcdecl(F) ::= type(T) ID(N) LPAREN idlist(P) RPAREN LBRACE 
                stmts(S) RBRACE. {
	struct list *t, *x; 
	struct pml_variable *p;

	F = (struct pml_function *)pmln_alloc(PMLTT_FUNCTION);
	F->name = (char *)N.u.raw.data;
	F->rtype = T;

	l_for_each_safe(t, x, &P->list) {
		F->arity += 1;
		p = container(t, struct pml_variable, ln);
		l_rem(&p->ln);
		if (pml_func_add_param(F, p) < 0) {
			pml_ast_err(ast, "Duplicate variable name: %s\n",
			            p->name);
			goto fd_out;
		}
	}
	pmln_free((union pml_node *)P);
	F->body = (union pml_node *)S;

fd_out:
}

inlinedecl(I) ::= INLINE ID(N) LPAREN idlist(P) RPAREN LBRACE expr(E) RBRACE. {
	struct list *t, *x;
	struct pml_variable *p;

	I = (struct pml_function *)pmln_alloc(PMLTT_FUNCTION);
	I->name = (char *)N.u.raw.data;
	I->rtype = PML_ETYPE_SCALAR;

	l_for_each_safe(t, x, &P->list) {
		I->arity += 1;
		p = container(t, struct pml_variable, ln);
		l_rem(&p->ln);
		if (pml_func_add_param(I, p) < 0) {
			pml_ast_err(ast, "Duplicate variable name: %s\n",
			            p->name);
			goto id_out;
		}
	}
	pmln_free((union pml_node *)P);
	I->body = (union pml_node *)E;
	I->flags |= PML_FF_INLINE;

id_out:
}

idlist(IL) ::= . { IL = (struct pml_list *)pmln_alloc(PMLTT_LIST); }
idlist(IL) ::= someids(IL2). { IL = IL2; }
someids(IL) ::= ID(V). {
	struct pml_variable *v = pml_var_alloc((char *)V.u.raw.data, 0, 
					       PML_VTYPE_PARAM, NULL);
	IL = (struct pml_list *)pmln_alloc(PMLTT_LIST);
	l_ins(&IL->list, &v->ln);
}
someids(IL) ::= someids(IL2) COMMA ID(V). {
	struct pml_variable *v = pml_var_alloc((char *)V.u.raw.data, 0,
					       PML_VTYPE_PARAM, NULL);
	l_enq(&IL2->list, &v->ln);
	IL = IL2;
}


gvar(G) ::= CONST ID(I) ASSIGN expr(E) SEMICOLON. {
	G = pml_var_alloc((char *)I.u.raw.data, 0, PML_VTYPE_CONST, E); 
}
gvar(G) ::= VAR ID(I) SEMICOLON. {
	G = pml_var_alloc((char *)I.u.raw.data, 0, PML_VTYPE_GLOBAL, NULL); 
}
gvar(G) ::= VAR ID(I) LBRACKET NUM(N) RBRACKET SEMICOLON. {
	G = pml_var_alloc((char *)I.u.raw.data, N.u.num, PML_VTYPE_GLOBAL,
			  NULL);
}
gvar(G) ::= VAR ID(I) ASSIGN expr(E) SEMICOLON. {
	if (!PML_EXPR_IS_CONST(E))
		pml_ast_err(ast, "Var '%s' initializer is not constant.\n",
			    (char *)I.u.raw.data);
	G = pml_var_alloc((char *)I.u.raw.data, 0, PML_VTYPE_GLOBAL, E); 
}
gvar(G) ::= VAR ID(I) LBRACKET NUM(N) RBRACKET ASSIGN value(VAL) SEMICOLON.{
	G = pml_var_alloc((char *)I.u.raw.data, N.u.num, PML_VTYPE_GLOBAL, VAL);
}

/* Rules */
rule(R) ::= pktpat(P) stmtlist(SL). {
	R = (struct pml_rule *)pmln_alloc(PMLTT_RULE);
	R->pattern = P;
	R->stmts = SL;
	R->trigger = PML_RULE_PACKET;
}

rule(R) ::= BEGIN stmtlist(SL). {
	R = (struct pml_rule *)pmln_alloc(PMLTT_RULE);
	R->pattern = NULL;
	R->stmts = SL;
	R->trigger = PML_RULE_BEGIN;
}

rule(R) ::= END stmtlist(SL). {
	R = (struct pml_rule *)pmln_alloc(PMLTT_RULE);
	R->pattern = NULL;
	R->stmts = SL;
	R->trigger = PML_RULE_END;
}

rule(R) ::= stmtlist(SL). {
	R = (struct pml_rule *)pmln_alloc(PMLTT_RULE);
	R->pattern = NULL;
	R->stmts = SL;
	R->trigger = PML_RULE_PACKET;
}


/* Statements */
stmtlist(SL) ::= LBRACE stmts(SS) RBRACE. { SL = SS; }

stmts(SS) ::= . {
	struct pml_list *l = (struct pml_list *)pmln_alloc(PMLTT_LIST);
	SS = l;
}
stmts(SSO) ::= stmt(S) stmts(SSI) . {
	l_ins(&SSI->list, &S->base.ln);
	SSO = SSI;
}


/* Specific types of statements */
stmt(S) ::= locator(L) ASSIGN expr(E) SEMICOLON. {
	struct pml_assign *a = (struct pml_assign *)pmln_alloc(PMLTT_ASSIGN);
	a->loc = L;
	a->expr = E;
	S = (union pml_node *)a;
}

stmt(S) ::= WHILE LPAREN expr(E) RPAREN stmtlist(SL). {
	struct pml_while *w = (struct pml_while *)pmln_alloc(PMLTT_WHILE);
	w->test = E;
	w->body = SL;
	S = (union pml_node *)w;
}

stmt(S) ::= IF LPAREN expr(E) RPAREN stmtlist(SL). {
	struct pml_if *i = (struct pml_if *)pmln_alloc(PMLTT_IF);
	i->test = E;
	i->tbody = SL;
	S = (union pml_node *)i;
}

stmt(S) ::= IF LPAREN expr(E) RPAREN stmtlist(SLT) ELSE stmtlist(SLF). {
	struct pml_if *i = (struct pml_if *)pmln_alloc(PMLTT_IF);
	i->test = E;
	i->tbody = SLT;
	i->fbody = SLF;
	S = (union pml_node *)i;
}

stmt(S) ::= RETURN expr(E) SEMICOLON.  {
	struct pml_cfmod *m = (struct pml_cfmod *)pmln_alloc(PMLTT_CFMOD);
	m->cftype = PML_CFM_RETURN;
	m->expr = E;
	S = (union pml_node *)m;
}

stmt(S) ::= cfmkw(C) SEMICOLON. {
	struct pml_cfmod *m = (struct pml_cfmod *)pmln_alloc(PMLTT_CFMOD);
	m->cftype = C;
	S = (union pml_node *)m;
}

cfmkw(C) ::= BREAK. { C = PML_CFM_BREAK; }
cfmkw(C) ::= CONTINUE. { C = PML_CFM_CONTINUE; }
cfmkw(C) ::= NEXTRULE. { C = PML_CFM_NEXTRULE; }
cfmkw(C) ::= SENDPKT. { C = PML_CFM_SENDPKT; }
cfmkw(C) ::= DROP. { C = PML_CFM_DROP; }

stmt(S) ::= PRINT STRING(FMT) SEMICOLON. {
	struct pml_print *p = (struct pml_print *)pmln_alloc(PMLTT_PRINT);
	pml_bytestr_copy(ast, &p->fmt, PML_SEG_ROMEM, FMT.u.raw.data,
			 FMT.u.raw.len);
	p->args = (struct pml_list *)pmln_alloc(PMLTT_LIST);
	free(FMT.u.raw.data);
	S = (union pml_node *)p;
}

stmt(S) ::= PRINT STRING(FMT) COMMA exprlist(EL) SEMICOLON. {
	struct pml_print *p = (struct pml_print *)pmln_alloc(PMLTT_PRINT);
	pml_bytestr_copy(ast, &p->fmt, PML_SEG_ROMEM, FMT.u.raw.data,
			 FMT.u.raw.len);
	p->args = EL;
	free(FMT.u.raw.data);
	S = (union pml_node *)p;
}

stmt(S) ::= expr(E) SEMICOLON. { S = (union pml_node *)E; }

pktpat(PP) ::= PPBEGIN expr(E) PPEND. { PP = E; }

expr(E) ::= orexpr(OE). { E = OE; }

orexpr(E) ::= andexpr(LHS) OR orexpr(RHS). {
	E = pml_binop_alloc(PMLOP_OR, LHS, RHS); 
}
orexpr(E) ::= andexpr(AE). { E = AE; }

andexpr(E) ::= cmpexpr(LHS) AND andexpr(RHS). {
	E = pml_binop_alloc(PMLOP_AND, LHS, RHS); 
}
andexpr(E) ::= cmpexpr(CE). { E = CE; }

cmpexpr(E) ::= borexpr(LHS) cmpop(OP) borexpr(RHS). {
	E = pml_binop_alloc(OP, LHS, RHS); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) BYTESTR(T1) DIV BYTESTR(T2). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_MASKVAL);
	pml_bytestr_copy(ast, &v->u.maskval.val, PML_SEG_ROMEM, T1.u.raw.data,
			 T1.u.raw.len);
	pml_bytestr_copy(ast, &v->u.maskval.mask, PML_SEG_ROMEM, T2.u.raw.data,
			 T2.u.raw.len);
	free(T1.u.raw.data);
	free(T2.u.raw.data);
	E = pml_binop_alloc(OP, LHS, (union pml_expr_u *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) IPV4ADDR(A) DIV NUM(L). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_MASKVAL);
	uchar mask[4] = { 0 };
	int i, rem;

	pml_bytestr_copy(ast, &v->u.maskval.val, PML_SEG_ROMEM, A.u.v4addr, 4);

	if (L.u.num > 32)
		pml_ast_err(ast, "IPv4 address mask > 32 bits in length\n");
	i = 0;
	rem = L.u.num;
	while (rem > 8) {
		mask[i++] = 0xff;
		rem -= 8;
	}
	mask[i] = 0xFF - ((1 << (8 - rem)) - 1);

	pml_bytestr_copy(ast, &v->u.maskval.mask, PML_SEG_ROMEM, mask, 4);

	E = pml_binop_alloc(OP, LHS, (union pml_expr_u *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) IPV4ADDR(A1) DIV IPV4ADDR(A2). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_MASKVAL);
	pml_bytestr_copy(ast, &v->u.maskval.val, PML_SEG_ROMEM, A1.u.v4addr, 4);
	pml_bytestr_copy(ast, &v->u.maskval.mask, PML_SEG_ROMEM, A2.u.v4addr, 4);
	E = pml_binop_alloc(OP, LHS, (union pml_expr_u *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) IPV6ADDR(A) DIV NUM(L). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_MASKVAL);
	uchar mask[16] = { 0 };
	int i, rem;

	pml_bytestr_copy(ast, &v->u.maskval.val, PML_SEG_ROMEM, A.u.v6addr, 16);

	if (L.u.num > 128)
		pml_ast_err(ast, "IPv6 address mask > 128 bits in length.\n");
	i = 0;
	rem = L.u.num;
	while (rem > 8) {
		mask[i++] = 0xff;
		rem -= 8;
	}
	mask[i] = 0xFF - ((1 << (8 - rem)) - 1);

	pml_bytestr_copy(ast, &v->u.maskval.mask, PML_SEG_ROMEM, mask, 16);

	E = pml_binop_alloc(OP, LHS, (union pml_expr_u *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) IPV6ADDR(A1) DIV IPV6ADDR(A2). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_MASKVAL);
	pml_bytestr_copy(ast, &v->u.maskval.val, PML_SEG_ROMEM, A1.u.v6addr, 16);
	pml_bytestr_copy(ast, &v->u.maskval.mask, PML_SEG_ROMEM, A2.u.v6addr, 16);
	E = pml_binop_alloc(OP, LHS, (union pml_expr_u *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) ETHADDR(E1) DIV ETHADDR(E2). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_MASKVAL);
	pml_bytestr_copy(ast, &v->u.maskval.val, PML_SEG_ROMEM, E1.u.ethaddr, 6);
	pml_bytestr_copy(ast, &v->u.maskval.mask, PML_SEG_ROMEM, E2.u.ethaddr, 6);
	E = pml_binop_alloc(OP, LHS, (union pml_expr_u *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) locname(L). {
	struct pml_literal *v;
	int op = (OP == PMLOP_MATCH) ? PMLOP_MATCH : PMLOP_NOTMATCH;
	E = NULL;
	v = pml_lookup_ns_literal(ast, L);
	if (v == NULL) {
		pml_ast_err(ast, "unable to find protocol value '%s'",
			    L->name);
	} else if (v->type == PMLTT_SCALAR) {
		pmln_free((union pml_node *)v);
		pml_ast_err(ast, "Protocol field '%s' on right side of match "
				 "operator is neither a byte nor mask string",
			    L->name);
	} else {
		E = pml_binop_alloc(op, LHS, (union pml_expr_u *)v);
	}
	pmln_free((union pml_node *)L);
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) REGEX(R). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_BYTESTR);
	int op = (OP == PMLOP_MATCH) ? PMLOP_REXMATCH : PMLOP_NOTREXMATCH;
	pml_bytestr_copy(ast, &v->u.bytestr, PML_SEG_ROMEM, R.u.raw.data, R.u.raw.len);
	free(R.u.raw.data);
	E = pml_binop_alloc(op, LHS, (union pml_expr_u *)v); 
}
cmpexpr(E) ::= borexpr(LHS). { E = LHS; }

matchop(OP) ::= MATCH. { OP = PMLOP_MATCH; }
matchop(OP) ::= NOMATCH. { OP = PMLOP_NOTMATCH; }

cmpop(OP) ::= EQ. { OP = PMLOP_EQ; }
cmpop(OP) ::= NEQ. { OP = PMLOP_NEQ; }
cmpop(OP) ::= LT. { OP = PMLOP_LT; }
cmpop(OP) ::= GT. { OP = PMLOP_GT; }
cmpop(OP) ::= LEQ. { OP = PMLOP_LEQ; }
cmpop(OP) ::= GEQ. { OP = PMLOP_GEQ; }

borexpr(E) ::= bxorexpr(LHS) BOR borexpr(RHS). {
	E = pml_binop_alloc(PMLOP_BOR, LHS, RHS); 
}
borexpr(E) ::= bxorexpr(BX). { E = BX; }

bxorexpr(E) ::= bandexpr(LHS) BXOR bxorexpr(RHS). {
	E = pml_binop_alloc(PMLOP_BXOR, LHS, RHS); 
}
bxorexpr(E) ::= bandexpr(BA). { E = BA; }

bandexpr(E) ::= addexpr(LHS) AMP bandexpr(RHS). {
	E = pml_binop_alloc(PMLOP_BAND, LHS, RHS); 
}
bandexpr(E) ::= addexpr(A). { E = A; }

addexpr(E) ::= mulexpr(LHS) PLUS addexpr(RHS). {
	E = pml_binop_alloc(PMLOP_PLUS, LHS, RHS); 
}
addexpr(E) ::= mulexpr(LHS) MINUS addexpr(RHS). {
	E = pml_binop_alloc(PMLOP_MINUS, LHS, RHS); 
}
addexpr(E) ::= mulexpr(M). { E = M; }

mulexpr(E) ::= shiftexpr(LHS) TIMES mulexpr(RHS). {
	E = pml_binop_alloc(PMLOP_TIMES, LHS, RHS); 
}
mulexpr(E) ::= shiftexpr(LHS) DIV mulexpr(RHS). {
	E = pml_binop_alloc(PMLOP_DIV, LHS, RHS); 
}
mulexpr(E) ::= shiftexpr(LHS) MOD mulexpr(RHS). {
	E = pml_binop_alloc(PMLOP_MOD, LHS, RHS); 
}
mulexpr(E) ::= shiftexpr(S). { E = S; }

shiftexpr(E) ::= uexpr(LHS) shiftop(OP) shiftexpr(RHS). {
	E = pml_binop_alloc(OP, LHS, RHS); 
}
shiftexpr(E) ::= uexpr(U). { E = U; }

shiftop(OP) ::= SHL. { OP = PMLOP_SHL; }
shiftop(OP) ::= SHR. { OP = PMLOP_SHR; }

uexpr(E) ::= NOT pexpr(PE). { E = pml_unop_alloc(PMLOP_NOT, PE); }
uexpr(E) ::= BINV pexpr(PE). { E = pml_unop_alloc(PMLOP_BINV, PE); }
uexpr(E) ::= MINUS pexpr(PE). { E = pml_unop_alloc(PMLOP_NEG, PE); }
uexpr(E) ::= pexpr(PE). { E = PE; }

pexpr(PE) ::= LPAREN expr(E) RPAREN. { PE = E; }
pexpr(PE) ::= call(C). { PE = (union pml_expr_u *)C; }
pexpr(PE) ::= value(V). { PE = (union pml_expr_u *)V; }

call(C) ::= ID(N) LPAREN exprlist(A) RPAREN. { 
	struct pml_function *f;
	char *name = (char *)N.u.raw.data;
	f = pml_ast_lookup_func(ast, name); 
	if (f != NULL) {
		C = pml_call_alloc(ast, f, A);
	} else {
		pml_ast_err(ast, "Undefined function: %s\n", name);
	}
	free(name);
}
call(C) ::= ID(N) LPAREN RPAREN. { 
	struct pml_function *f;
	struct pml_list *args;
	char *name = (char *)N.u.raw.data;
	f = pml_ast_lookup_func(ast, name);
	if (f != NULL) {
		args = (struct pml_list *)pmln_alloc(PMLTT_LIST);
		C = pml_call_alloc(ast, f, args);
	} else {
		pml_ast_err(ast, "Undefined function: %s\n", name);
	}
	free(name);
}
exprlist(EL1) ::= exprlist(EL0) COMMA expr(E). { 
	l_enq(&EL0->list, &E->base.ln);
	EL1 = EL0;
}
exprlist(EL) ::= expr(E). { 
	struct pml_list *l = (struct pml_list *)pmln_alloc(PMLTT_LIST);
	l_enq(&l->list, &E->base.ln);
	EL = l;
}

value(V) ::= locator(L). { 
	V = (union pml_expr_u *)L;
}
value(V) ::= AMP locname(L). { 
	L->type = PMLTT_LOCADDR;
	V = (union pml_expr_u *)L;
}
value(V) ::= BYTESTR(I). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_BYTESTR);
	pml_bytestr_copy(ast, &v->u.bytestr, PML_SEG_ROMEM, I.u.raw.data,
			 I.u.raw.len);
	free(I.u.raw.data);
	V = (union pml_expr_u *)v;
}
value(V) ::= IPADDR(I). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_BYTESTR);
	pml_bytestr_copy(ast, &v->u.bytestr, PML_SEG_ROMEM, I.u.v4addr, 4);
	V = (union pml_expr_u *)v;
}
value(V) ::= IPV6ADDR(I). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_BYTESTR);
	pml_bytestr_copy(ast, &v->u.bytestr, PML_SEG_ROMEM, I.u.v6addr, 16);
	V = (union pml_expr_u *)v;
}
value(V) ::= ETHADDR(I). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_BYTESTR);
	pml_bytestr_copy(ast, &v->u.bytestr, PML_SEG_ROMEM, I.u.ethaddr, 6);
	V = (union pml_expr_u *)v;
}
value(V) ::= numval(N). { V = (union pml_expr_u *)N; }
value(V) ::= STRING(I). {
	struct pml_literal *v = (struct pml_literal *)pmln_alloc(PMLTT_BYTESTR);
	pml_bytestr_copy(ast, &v->u.bytestr, PML_SEG_ROMEM, I.u.raw.data,
			 I.u.raw.len);
	free(I.u.raw.data);
	V = (union pml_expr_u *)v;
}
value(V) ::= ATAT locname(L). {
	struct ns_elem *ne = ns_lookup(NULL, L->name);
	struct pml_literal *v;
	if (ne == NULL) {
		pml_ast_err(ast, "invalid @location: '%s'\n", L->name);
	} else if (ne->type == NST_NAMESPACE) {
		struct ns_namespace *ns = (struct ns_namespace *)ne;
		v = (struct pml_literal *)pmln_alloc(PMLTT_SCALAR);
		v->width = 8;
		v->u.scalar = ns->prid;
	} else if (ne->type != NST_PKTFLD) {
		struct ns_pktfld *pf = (struct ns_pktfld *)ne;
		v = (struct pml_literal *)pmln_alloc(PMLTT_SCALAR);
		v->width = 8;
		v->u.scalar = pf->prid;
	} else {
		pml_ast_err(ast, "@location '%s' is neither a namespace "
				 "or a packet field\n", L->name);
	}
	pmln_free((union pml_node *)L);
	V = (union pml_expr_u *)v;
}

locator(V) ::= locname(N). { V = N; }
locator(V) ::= locname(N) LBRACKET expr(O) COMMA expr(L) RBRACKET. {
	N->off = O;
	N->len = L;
	V = N;
}

locator(V) ::= locname(N) LBRACKET expr(O) RBRACKET. {
	N->off = O;
	V = N;
}

locname(L) ::= pktname(P). { L = P; }
locname(L1) ::= locstr(L0). { L1 = L0; }
locname(L1) ::= pktname(P) DOT locstr(L0). {
	if (pml_locator_extend_name(P, L0->name, strlen(L0->name)) < 0)
		pml_ast_err(ast, "Out of memory for string.\n");
	pmln_free((union pml_node *)L0);
	L1 = P;
	L1->reftype = PML_REF_UNKNOWN_NS_ELEM;
}

locstr(L1) ::= locstr(L0) DOT ID(TOK). {
	if (pml_locator_extend_name(L0, (char *)TOK.u.raw.data, 
				    TOK.u.raw.len) < 0)
		pml_ast_err(ast, "Out of memory for string.\n");
	free(TOK.u.raw.data);
	L1 = L0;
	L1->reftype = PML_REF_UNKNOWN_NS_ELEM;
}
locstr(L) ::= ID(TOK). { 
	L = (struct pml_locator *)pmln_alloc(PMLTT_LOCATOR);
	L->name = (char *)TOK.u.raw.data;
}

pktname(L) ::= AT ID(TOK) LBRACE expr(PK) COMMA expr(IDX) RBRACE. {
	L = (struct pml_locator *)pmln_alloc(PMLTT_LOCATOR);
	L->name = (char *)TOK.u.raw.data;
	L->pkt = PK;
	L->idx = IDX;
	L->reftype = PML_REF_UNKNOWN_NS_ELEM;
}
pktname(L) ::= AT ID(TOK) LBRACE expr(PK) RBRACE. {
	L = (struct pml_locator *)pmln_alloc(PMLTT_LOCATOR);
	L->name = (char *)TOK.u.raw.data;
	L->pkt = PK;
	L->reftype = PML_REF_UNKNOWN_NS_ELEM;
}

numval(N) ::= NUM(TOK). {
	N = (struct pml_literal *)pmln_alloc(PMLTT_SCALAR);
	N->width = 8;
	N->u.scalar = TOK.u.num;
}
