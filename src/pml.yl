/*
?- tcp.sport == tcp.ports.http -?

?- ip.saddr == 127.0.0.0/24 -?

?- eth && ip6 && pkt.len > ip6.len + 40 + 14 -?

?- pop(tcp.flags) == 2 -?

?- nlz(ip6.flowid) == 4 -?

?- eth.saddr =/ c0:2a:f9:00:00:00/ff:ff:ff:f0:00:00 -?
?- eth.saddr !/ c0:2a:f9:00:00:00/ff:ff:ff:f0:00:00 -?  

?- not (pkt.data =~ "hello +world!") -?
?- not (pkt.data !~ "hello +world!") -?

?- tcp.dport == tcp.ports.reserved -?

?- uint(tcp[2:2]) == 1628 -?

?- tcp[2:10] == \xABCDEF0123DEADBEEF01/FEEDA110FFFFFFFFAB -?

?- ip:1[3:1] == "a" -?


?- eth.saddr == 5 -? # error
*/


/* 
  Actions:

  Drop
  Insert space
  Cut space
  Duplicate
  Push header
  Fix lengths
  Fix checksum
  Fix dlt
  Enqueue packet
  Set field/variable
  Fun call 
  Print
  Return

  if () { 
  }

  while () { 
  }


  Declarations:
  function name ( arg1, arg2 ... ) {
    <local variable declarations here>

    <action list>
    
    return(v1, v2, ...);
  }

  var name;
  var name[width];
*/

/* ----- Basic Lemon Declarations ----- */

%name PML
%token_prefix PMLTOK_
%include { #include "pmltree.h" }
%extra_argument { struct pml_prog *program }

/* ----- Mappings between non-terminals and C types ----- */

%type rule { struct pml_tree * }
%destructor rule { pmlt_free($$); }

%type pktpat { struct pml_expr_u * }
%destructor pktpat { pmlt_free($$); }

%type expr { union pml_expr_u * }
%destructor expr { pmlt_free($$); }

%type stmt { struct pml_stmt * }
%destructor stmt { pmlt_free($$); }

%type stmtlist { struct pml_list * }
%destructor stmtlist { pmlt_free($$); }

%type pktact { struct pml_pkt_action * }
%destructor pktact { pmlt_free($$); }

%type var { struct variable * }
/* no destructor: cleaned up on program cleanup or function destructor */

%type exprlist { struct pml_list * }
%destructor exprlist { pmlt_free($$); }

%type pktoff { struct pml_locator * }
%destructor pktoff { pmlt_free($$); }

%type locator { struct pml_locator * }
%destructor locator { pmlt_free($$); }

%type idlist { struct pml_list * }
%destructor idlist { pmlt_free($$); }

%type type { int }

%type orexpr { struct pml_binop * } 
%destructor orexpr { pmlt_free($$); }

%type andexpr { struct pml_binop * } 
%destructor andexpr { pmlt_free($$); }

%type cmpexpr { struct pml_binop * } 
%destructor cmpexpr { pmlt_free($$); }

%type maskop { int }
%type cmpop  { int }

%type borexpr { struct pml_binop * } 
%destructor borexpr { pmlt_free($$); }

%type bxorexpr { struct pml_binop * } 
%destructor bxorexpr { pmlt_free($$); }

%type bandexpr { struct pml_binop * } 
%destructor bandexpr { pmlt_free($$); }

%type addexpr { struct pml_binop * } 
%destructor addexpr { pmlt_free($$); }

%type mulexpr { struct pml_binop * } 
%destructor mulexpr { pmlt_free($$); }

%type shiftexpr { struct pml_binop * } 
%destructor shiftexpr { pmlt_free($$); }

%type shiftop { int }

%type uexpr { struct pml_unop * } 
%destructor uexpr { pmlt_free($$); }

%type valexpr { struct pml_value * } 
%destructor valexpr { pmlt_free($$); }

%type intrinsic { int }

%type field { union pml_field_u * } 
%destructor field { pmlt_free($$); }

/* ----- Grammar ----- */

prog ::= decllist.

decllist ::= decllist decl.
decllist ::= decllist rule.
decllist ::= .


rule ::= pktpat stmt.
rule ::= pktpat stmtlist.

stmtlist ::= LBRACE stmts RBRACE.
stmts ::= stmt SEMICOLON.
stmts ::= stmts stmt SEMICOLON.

stmt ::= pktact.
stmt ::= var ASSIGN expr.
stmt ::= WHILE stmtlist.
stmt ::= IF LPAREN expr RPAREN stmtlist.
stmt ::= IF LPAREN expr RPAREN stmtlist ELSE stmtlist.
stmt ::= RETURN expr.
stmt ::= PRINT STRING.
stmt ::= PRINT STRING COMMA exprlist.

pktact ::= DROP.
pktact ::= DROP ID.
pktact ::= INSERT pktoff expr.
pktact ::= CUT pktoff expr.
pktact ::= DUP NUM.
pktact ::= DUP ID NUM.
pktact ::= FIXLEN.
pktact ::= FIXLEN locator.
pktact ::= FIXCSUM locator.
pktact ::= FIXDLT locator.
pktact ::= ENQUEUE ID.


decl ::= funcdecl.
decl ::= vardecl.

funcdecl ::= DEF ID LPAREN idlist RPAREN LBRACE vardecls stmts RBRACE.
idlist ::= .
idlist ::= someids.
someids ::= ID.
someids ::= someids COMMA ID.

vardecl ::= type ID SEMICOLON.
vardecl ::= type ID LBRACKET NUM RBRACKET.
vardecls ::= .
vardecls ::= vardecls vardecl.

pktpat ::= PPBEGIN expr PPEND.

expr ::= orexpr.

orexpr ::= orexpr OR andexpr.
orexpr ::= andexpr.

andexpr ::= andexpr AND cmpexpr.
andexpr ::= cmpexpr.

cmpexpr ::= BYTESTR REX STRING.
cmpexpr ::= BYTESTR NOTREX STRING.
cmpexpr ::= borexpr cmpop borexpr.
cmpexpr ::= borexpr maskop BYTESTR DIV BYTESTR.
cmpexpr ::= borexpr maskop IPV4ADDR DIV NUM.
cmpexpr ::= borexpr maskop IPV6ADDR DIV NUM.
cmpexpr ::= borexpr maskop ETHADDR DIV ETHADDR.
cmpexpr ::= borexpr.

maskop ::= MASKEQ.
maskop ::= MASKNE.

cmpop ::= EQ.
cmpop ::= NEQ.
cmpop ::= LT.
cmpop ::= GT.
cmpop ::= LEQ.
cmpop ::= GEQ.

borexpr ::= borexpr BOR bxorexpr.
borexpr ::= bxorexpr.

bxorexpr ::= bxorexpr BXOR bandexpr.
bxorexpr ::= bandexpr.

bandexpr ::= bandexpr BAND addexpr.
bandexpr ::= addexpr.

addexpr ::= addexpr PLUS mulexpr.
addexpr ::= addexpr MINUS mulexpr.
addexpr ::= mulexpr.

mulexpr ::= mulexpr TIMES shiftexpr.
mulexpr ::= mulexpr DIV shiftexpr.
mulexpr ::= mulexpr MOD shiftexpr.
mulexpr ::= shiftexpr.

shiftexpr ::= shiftexpr shiftop uexpr.
shiftexpr ::= uexpr.

shiftop ::= SHL.
shiftop ::= SHR.
shiftop ::= SHRA.

uexpr ::= NOT valexpr.
uexpr ::= BINV valexpr.
uexpr ::= MINUS valexpr.
uexpr ::= valexpr.

valexpr ::= LPAREN expr RPAREN.
valexpr ::= intrinsic LPAREN expr RPAREN.
valexpr ::= funcall.
valexpr ::= field.

intrinsic ::= POP.
intrinsic ::= NLZ.
intrinsic ::= type.

type ::= UINT8.
type ::= INT8.
type ::= UINT16.
type ::= INT16.
type ::= UINT32.
type ::= INT32.

funcall ::= ID LPAREN exprlist RPAREN.
funcall ::= ID LPAREN RPAREN.

exprlist ::= exprlist COMMA expr.
exprlist ::= expr.

field ::= var.
field ::= BYTESTR.
field ::= IPADDR.
field ::= IPV6ADDR.
field ::= NUM.
field ::= STRING.

var ::= locator.
var ::= locator LBRACKET borexpr COLON borexpr RBRACKET.

locator ::= locator DOT ID.
locator ::= ID.

pktoff ::= locator.
pktoff ::= locator LBRACKET borexpr RBRACKET.
