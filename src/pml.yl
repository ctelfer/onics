/*


# Comment 

?- tcp.sport == tcp.ports.http -?

# Match operator is =~, inverse is !~
# Takes field on one side, pattern other
# Patterns include:
#   IP[v6] w/ mask, bytestring w/ mask, eth addr w/ mask,
#   regex, numeric range
#
?- ip.saddr =~ 127.0.0.0/24 -?          # IP w/mask
?- eth.saddr !~ c0:2a:f9:00:00:00/ff:ff:ff:f0:00:00 -?  # eth addr
?- not (pkt.data =~ "hello world!") -?  # ascii string match
?- not (pkt.data !~ \xa5a6a7a8a9aaabac) -?  # byte string match 
?- pkt.data =~ `hello +world!` -?       # regex
?- ipv6.daddr =~ ff80:abcd::/8 -?	# ipv6 w/mask
?- tcp.dport !~ tcp.ports.reserved -?   # numeric range
?- udp.sport !~ [0..1023] -?		# numeric range
?- tcp[2:10] =~ \xABCDEF0123DEADBEEF01/FEEDA110FFFFFFFFAB -? # bytes w/ mask

# Short circuiting boolean ops are supported of course
?- eth && ip6 && pkt.len > ip6.len + 40 + 14 -?

?- pop(tcp.flags == 2) -?

?- nlz(ip6.flowid) == 4 -?

?- tcp[2:2] == 1628 -?

# second IP header in the 
?- ip[1][3:1] == 65 -?

# compares as 64-bit integer
?- eth.saddr == 5 -? 

# compares first 8 bytes as 64-bit integer
# probably not intended 
?- ipv6.saddr == 5 -? 

# A predicate is pure function that calls only other predicates
# and is not recursive (neither directly or indirectly.
# The reason is that predicates are shorthand mainly for matching and
# need to be able to be used in a matchonly program with only forward
# branches.
pred ishttp() ( tcp && (tcp.sport == 80 || tcp.dport == 80) )

# A function can be recursive, have local variables and it has
# a series of statements enclosed in parentheses.
# All variable declarations must come before statements.
func incr(v) {
	var x;

	x = v + 1;
	return x;
}
var Count;

# Patterns can call predicates.  (for shorthand)
?- ishttp() -? { Count = incr(Count); }

*/


/* 

  Variables -- local all variables are 32 bit numbers (for now); will add more
               types later.  (8, 16, 32, 64-bit signed and unsigned, plus 
               bytestrings)
  Local variables are referred to by name
  

  Abstractions:
   - PRID == protocol ID, identifies a parsable protocol
   - PKID == packet ID, identifies one of the 16 packets in the working set
   - FLD == field, a unit of data that has meaning within a protocol
            There are 2 data types of fields:
	      - bit fields - width <= 32 bits and do not start at byte offsets
	      - byte string - Starts at a byte offset, and can have any width.
	            data within the field can be interpreted in any desired
		    way.
		    * byte strings of 8 or less bytes can be operated on as
		      numeric values.

	    There are 3 special field access characteristics
	      - Required -- cannot be unset  (e.g. start offset)
	      - Derived position -- cannot be unset and offset does not move 
	          with an 'insert' or 'cut' unless the offset(s) it depends
		  upon also move.
	      - Derived value -- cannot be set or unset, field is not present
	          in the data explicitly, but derived from offsets or other
		  fields in the data.

  Notation:
   a			-- Variable name (global or local) or proto name
   $<protoname>		-- Protocol ID 
   a.b.c.d		-- Field for packet 0
   @<pkt>:a.b.c.d	-- Field for packet <pkt>
   &<field>		-- Byte offset for a field <byte string or integer>


  Intrinsic Functions:

   - Drop
   - Fix dlt
   - Insert space
   - Cut space
   - Duplicate
   - Push header inner or outer
   - Pop header inner or outer
   - Update header
   - Fix lengths
   - Fix checksum
   - Enqueue packet
   - Dequeue packet
   - Send packet queue
   - (Un)Set layer
   - pop(ulation count)
   - nlz (number of leading zeroes)
   - signext (sign extend a value)

  Statements: 
   - Any expression (including function calls)
   - if then else
   - while
   - Set field/variable
   - Print
   - Return


  Example:
	insert(10, &tcp + 20); #insert 10 bytes of data 20-bytes after the TCP section star
	insert(4, &net + 20, 20);
	cut(10, &ip + ip.hl * 4);
	fixcsum();

  if () { 
  }

  while () { 
  }


  Declarations:
  function name ( arg1, arg2 ... ) {
    <local variable declarations here>

    <action list>
    
    return(v1, v2, ...);
  }

  var name;
  var name[width];
*/

/* ----- Basic Lemon Declarations ----- */

%name PML
%token_prefix PMLTOK_
%include { 
#include <string.h>
#include <cat/cat.h>
#include <cat/list.h>
#include "pmltree.h" 
#include "pmllex.h"
}
%extra_argument { struct pml_ast *ast }

/* ----- Mappings between non-terminals and C types ----- */

%type decl { union pml_tree * }
%destructor decl { pmlt_free($$); }

%type fundecl { struct pml_function * }
%destructor fundecl { pmlt_free($$); }

%type preddecl { struct pml_function * }
%destructor preddecl { pmlt_free($$); }

%type lvar { struct pml_variable * }
%destructor lvar { pmlt_free($$); }

%type gvar { struct pml_variable * }
%destructor gvar { pmlt_free($$); }

%type lvardecls { struct pml_list * }
%destructor lvardecls { pmlt_free($$); }

%type rule { struct pml_rule * }
%destructor rule { pmlt_free($$); }

%type pktpat { struct pml_expr_u * }
%destructor pktpat { pmlt_free($$); }

%type expr { union pml_expr_u * }
%destructor expr { pmlt_free($$); }

%type stmt { union pml_tree * }
%destructor stmt { pmlt_free($$); }

%type stmtlist { struct pml_list * }
%destructor stmtlist { pmlt_free($$); }

%type stmts { struct pml_list * }
%destructor stmts { pmlt_free($$); }

%type var { struct pml_locator * }
%destructor var { pmlt_free($$); }

%type exprlist { struct pml_list * }
%destructor exprlist { pmlt_free($$); }

%type locator { struct pml_locator * }
%destructor locator { pmlt_free($$); }

%type idlist { struct pml_list * }
%destructor idlist { pmlt_free($$); }

%type someids { struct pml_list * }
%destructor someids { pmlt_free($$); }

%type type { int }

%type orexpr { union pml_expr_u * } 
%destructor orexpr { pmlt_free($$); }

%type andexpr { union pml_expr_u * } 
%destructor andexpr { pmlt_free($$); }

%type cmpexpr { union pml_expr_u * } 
%destructor cmpexpr { pmlt_free($$); }

%type maskop { int }
%type cmpop  { int }

%type borexpr { union pml_expr_u * } 
%destructor borexpr { pmlt_free($$); }

%type bxorexpr { union pml_expr_u * } 
%destructor bxorexpr { pmlt_free($$); }

%type bandexpr { union pml_expr_u * } 
%destructor bandexpr { pmlt_free($$); }

%type addexpr { union pml_expr_u * } 
%destructor addexpr { pmlt_free($$); }

%type mulexpr { union pml_expr_u * } 
%destructor mulexpr { pmlt_free($$); }

%type shiftexpr { union pml_expr_u * } 
%destructor shiftexpr { pmlt_free($$); }

%type shiftop { int }

%type uexpr { union pml_expr_u * } 
%destructor uexpr { pmlt_free($$); }

%type pexpr { union pml_expr_u * } 
%destructor pexpr { pmlt_free($$); }

%type valexpr { union pml_expr_u * } 
%destructor valexpr { pmlt_free($$); }

%type value { union pml_value_u * } 
%destructor value { pmlt_free($$); }

%type funcall { struct pml_funcall * } 
%destructor funcall { pmlt_free($$); }

%type numval { struct pml_value * }
%destructor numval { pmlt_free($$); }

%token_type { struct pml_lex_val }
%token_destructor { 
	if ($$.type == PMLLV_STRING) {
		free($$.u.raw.data);
		$$.u.raw.data = NULL;
	}
}

/* ----- Grammar ----- */

prog ::= decllist. /* nothing to do */

/* Declarations */
decllist ::= decllist decl. /* nothing to do: resolved below. */

decllist ::= decllist rule(A). {
	l_ins(&ast->pmla_rules.prev, &A->pml_node->pmln_ln);
}

decllist ::= . /* nothing to do */

decl ::= fundecl(F). {
	if (pml_ast_add_func(ast, F) < 0) {
		pml_ast_err(ast, "Duplicate function/predicate: %s\n", 
		            F->pmlf_name);
		ast->pmla_error = 1;
		pmlt_free((union pml_tree *)F);
	}
}
decl ::= preddecl(F). {
	if (pml_ast_add_func(ast, F) < 0) {
		pml_ast_err(ast, "Duplicate function/predicate: %s\n", 
		            F->pmlf_name);
		ast->pmla_error = 1;
		pmlt_free((union pml_tree *)F);
	}
}
decl ::= gvar(V). {
	if (pml_ast_add_var(ast, V) < 0) {
		pml_ast_err(ast, "Duplicate variable: %s\n", V->pmlvar_name);
		ast->pmla_error = 1;
		pmlt_free((union pml_tree *)V);
	}
}

preddecl(F) ::= PRED ID(N) LPAREN idlist(P) RPAREN LPAREN expr(E) RPAREN. {
	struct list *t; 
	struct pml_variable *p;

	F = (struct pml_function *)pmlt_alloc(PMLTT_PRED);
	F->pmlf_name = N.u.raw.data;

	l_for_each(t, &P->pmll_list) {
		F->pmlv_arity += 1;
		p = container(t, struct pml_variable, pmlvar_ln);
		if (pml_func_add_var(F, p) < 0) {
			pml_ast_err(ast, "Duplicate variable name: %s\n",
			            p->pmlvar_name);
			ast->pmla_error = 1;
			goto out:
		}
	}
	F->pmlf_prmlist = P;

	F->pmlf_body = (union pml_tree *)E;

out:
}

fundecl(F) ::= FUNC ID(N) LPAREN idlist(P) RPAREN LBRACE lvardecls(V) 
               stmts(S) RBRACE. {
	struct list *t; 
	struct pml_variable *p;

	F = (struct pml_function *)pmlt_alloc(PMLTT_FUNC);
	F->pmlf_name = N.u.raw.data;

	l_for_each(t, &P->pmll_list) {
		F->pmlv_arity += 1;
		p = container(t, struct pml_variable, pmlvar_ln);
		if (pml_func_add_var(F, p) < 0) {
			pml_ast_err(ast, "Duplicate variable name: %s\n",
			            p->pmlvar_name);
			ast->pmla_error = 1;
			goto out:
		}
	}
	F->pmlf_prmlist = P;

	l_for_each(t, &V->pmll_list) {
		p = container(t, struct pml_variable, pmlvar_ln);
		if (pml_func_add_var(F, p) < 0) {
			pml_ast_err(ast, "Duplicate variable name: %s\n",
			            p->pmlvar_name);
			ast->pmla_error = 1;
			goto out:
		}
	}
	F->pmlf_varlist = V;

	F->pmlf_body = (union pml_tree *)S;

out:
}

idlist(IL) ::= . { IL = (struct pml_list *)pmlt_alloc(PMLTT_LIST); }
idlist(IL) ::= someids(IL2). { IL = IL2; }
someids(IL) ::= ID(V). {
	struct pml_variable *v = pmlvar_alloc(V.u.raw.data, 4, NULL);
	IL = (struct pml_list *)pmlt_alloc(PMLTT_LIST);
	l_ins(&IL->pmll_list, &v->pmlv_ln);
}
someids(IL) ::= someids(IL2) COMMA ID(V). {
	struct pml_variable *v = pmlvar_alloc(V.u.raw.data, 4, NULL);
	l_ins(&IL2->pmll_list, &v->pmlv_ln);
	IL = IL2;
}


lvar(L) ::= VAR ID(I) SEMICOLON. { L = pmlvar_alloc(I.u.raw.data, 4, NULL); }
gvar(G) ::= lvar(L). { G = L; }
gvar(G) ::= VAR ID(I) LBRACKET NUM(N) RBRACKET. {
	G = pmlvar_alloc(I.u.raw.data, N.u.num, NULL);
}
gvar(G) ::= lvar(L) ASSIGN numval(V). {
	L->pmlvar_init = V;
	G = L;
}
gvar(G) ::= VAR ID(I) LBRACKET NUM(N) RBRACKET ASSIGN value(VAL). {
	G = pmlvar_alloc(I.u.raw.data, N.u.num, VAL);
}

lvardecls(L) ::= . {
	L = (struct pml_list *)pmlt_alloc(PMLTT_LIST);
}
lvardecls(L1) ::= lvardecls(L0) lvar(V).  {
	struct list *t; 
	l_for_each(t, &L0->pmll_list) {
		struct pml_variable *p;
		p = container(p, struct pml_variable, pmlvar_ln);
		if (strcmp(p->pmlvar_name, V->pmlvar_name) == 0) {
			pml_ast_err("Duplicate variable name: %s\n",
			            p->pmlvar_name);
			ast->pmla_error = 1;
			goto done;
		}
	}
	l_ins(&L0->pmll_list.prev, &V->pmlvar_ln);
done:
	L1 = L0;
}

/* Rules */
rule(R) ::= pktpat(P) stmtlist(SL). {
	R = (struct pml_rule *)pmlt_alloc(PMLTT_RULE);
	R->pmlr_pattern = P;
	R->pmlr_stmts = SL;
}


/* Statements */
stmtlist(SL) ::= LBRACE stmts(SS) RBRACE. { SL = SS; }

stmts(SS) ::= . {
	struct pml_list *l = (struct pml_list *)pmlt_alloc(PMLTT_LIST);
	SS = l;
}
stmts(SSO) ::= stmts(SSI) stmt(S) SEMICOLON. {
	l_ins(&SSI->pmll_list, &S->pmlt_node->pmln_ln);
	SSO = SSI;
}


/* Specific types of statements */
stmt(S) ::= var(V) ASSIGN expr(E). {
	struct pml_set_action *a = 
		(struct plm_set_action *)pmlt_alloc(PMLTT_SETACT);
	a->pmlsa_variable = V;
	a->pmlsa_expr = E;
	S = (union pml_tree *)a;
}

stmt(S) ::= WHILE LPAREN expr(E) RPAREN stmtlist(SL). {
	struct pml_while *w = (struct pml_while *)pmlt_alloc(PMLTT_WHILE);
	w->pmlw_test = E;
	w->pmlw_body = SL;
	S = (union pml_tree *)w;
}

stmt(S) ::= IF LPAREN expr(E) RPAREN stmtlist(SL). {
	struct pml_if *i = (struct pml_if *)pmlt_alloc(PMLTT_IF);
	i->pmlif_test = E;
	i->pmlif_tbody = SL;
	S = (union pml_tree *)i;
}

stmt(S) ::= IF LPAREN expr(E) RPAREN stmtlist(SLT) ELSE stmtlist(SLF). {
	struct pml_if *i = (struct pml_if *)pmlt_alloc(PMLTT_IF);
	i->pmlif_test = E;
	i->pmlif_tbody = SLT;
	i->pmlif_fbody = SLF;
	S = (union pml_tree *)i;
}

stmt(S) ::= RETURN expr(E).  {
	struct pml_return *r = (struct pml_return *)pmlt_alloc(PMLTT_RETURN);
	r->pmlret_expr = E;
	S = (union pml_tree *)r;
}

stmt(S) ::= PRINT STRING(TV). {
	struct pml_print *p = (struct pml_print *)pmlt_alloc(PMLTT_PRINT);
	p->pmlp_fmt = TV.u.raw.data;
	S = (union pml_tree *)p;
}

stmt(S) ::= PRINT STRING(TV) COMMA exprlist(EL). {
	struct pml_print *p = (struct pml_print *)pmlt_alloc(PMLTT_PRINT);
	p->pmlp_fmt = TV.u.raw.data;
	p->pmlp_args = EL;
	S = (union pml_tree *)p;
}

pktpat(PP) ::= PPBEGIN expr(E) PPEND. { PP = E; }

expr(E) ::= orexpr(OE). { E = OE; }

orexpr(E) ::= orexpr(LHS) OR andexpr(RHS). {
	E = pml_binop_alloc(PMLOP_OR, LHS, RHS); 
}
orexpr(E) ::= andexpr(AE). { E = AE; }

andexpr(E) ::= andexpr(LHS) AND cmpexpr(RHS). {
	E = pml_binop_alloc(PMLOP_AND, LHS, RHS); 
}
andexpr(E) ::= cmpexpr(CE). { E = CE; }

cmpexpr(E) ::= borexpr(LHS) cmpop(OP) borexpr(RHS). {
	E = pml_binop_alloc(OP, LHS, RHS); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) BYTESTR(T1) DIV BYTESTR(T2). {
	struct pml_value *v = (struct pml_value *)pmlt_alloc(PMLTT_MASKVAL);
	pml_bytestr_set_dynamic(&v->pmlv_mval, T1.u.raw.data, T1.u.raw.len);
	pml_bytestr_set_dynamic(&v->pmlv_mmval, T2.u.raw.data, T2.u.raw.len);
	E = pml_binop_alloc(OP, LHS, (union pml_expr *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) IPV4ADDR(A) DIV NUM(L). {
	struct pml_value *v = (struct pml_value *)pmlt_alloc(PMLTT_MASKVAL);
	uchar mask[4] = { 0 };
	int i, rem;

	pml_bytestr_set_static(&v->pmlv_mval, A.u.v4addr, 4);

	if (L.u.num > 32) {
		pml_ast_err(ast, "IPv4 address mask > 32 bits in length\n");
		ast->pmla_error = 1;
	}
	i = 0;
	rem = L.u.num;
	while (rem > 8) {
		mask[i++] = 0xff;
		rem -= 8;
	}
	mask[i] = 0xFF - ((1 << (8 - rem)) - 1);

	pml_bytestr_set_static(&v->pmlv_mmval, mask, 4);

	E = pml_binop_alloc(OP, LHS, (union pml_expr *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) IPV4ADDR(A1) DIV IPV4ADDR(A2). {
	struct pml_value *v = (struct pml_value *)pmlt_alloc(PMLTT_MASKVAL);
	pml_bytestr_set_static(&v->pmlv_mval, A1.u.v4addr, 4);
	pml_bytestr_set_static(&v->pmlv_mmval, A2.u.v4addr, 4);
	E = pml_binop_alloc(OP, LHS, (union pml_expr *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) IPV6ADDR(A) DIV NUM(L). {
	struct pml_value *v = (struct pml_value *)pmlt_alloc(PMLTT_MASKVAL);
	uchar mask[16] = { 0 };
	int i, rem;

	pml_bytestr_set_static(&v->pmlv_mval, A.u.v6addr, 16);

	if (L.u.num > 128) {
		pml_ast_err(ast, "IPv6 address mask > 128 bits in length.\n");
		ast->pmla_error = 1;
	}
	i = 0;
	rem = L.u.num;
	while (rem > 8) {
		mask[i++] = 0xff;
		rem -= 8;
	}
	mask[i] = 0xFF - ((1 << (8 - rem)) - 1);

	pml_bytestr_set_static(&v->pmlv_mmval, mask, 16);

	E = pml_binop_alloc(OP, LHS, (union pml_expr *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) IPV6ADDR(A1) DIV IPV6ADDR(A2). {
	struct pml_value *v = (struct pml_value *)pmlt_alloc(PMLTT_MASKVAL);
	pml_bytestr_set_static(&v->pmlv_mval, A1.u.v6addr, 16);
	pml_bytestr_set_static(&v->pmlv_mmval, A2.u.v6addr, 16);
	E = pml_binop_alloc(OP, LHS, (union pml_expr *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) ETHADDR(E1) DIV ETHADDR(E2). {
	struct pml_value *v = (struct pml_value *)pmlt_alloc(PMLTT_MASKVAL);
	pml_bytestr_set_static(&v->pmlv_mval, E1.u.ethaddr, 6);
	pml_bytestr_set_static(&v->pmlv_mmval, E2.u.ethaddr, 6);
	E = pml_binop_alloc(OP, LHS, (union pml_expr *)v); 
}
cmpexpr(E) ::= borexpr(LHS) matchop(OP) REGEX(R). {
	struct pml_value *v = (struct pml_value *)pmlt_alloc(PMLTT_BYTESTR);
	int op = (OP == PMLOP_MATCH) ? PMLOP_REXMATCH : PMLOP_NOTREXMATCH;
	pml_bytestr_set_dynamic(&v->pmlv_mval, R.u.raw.data, R.u.raw.len);
	E = pml_binop_alloc(op, LHS, (union pml_expr *)v); 
}
cmpexpr(E) ::= borexpr(LHS). { E = LHS; }

matchop(OP) ::= MATCH. { OP = PMLOP_MATCH; }
matchop(OP) ::= NOMATCH. { OP = PMLOP_NOTMATCH; }

cmpop(OP) ::= EQ. { OP = PMLOP_EQ; }
cmpop(OP) ::= NEQ. { OP = PMLOP_NEQ; }
cmpop(OP) ::= LT. { OP = PMLOP_LT; }
cmpop(OP) ::= GT. { OP = PMLOP_GT; }
cmpop(OP) ::= LEQ. { OP = PMLOP_LEQ; }
cmpop(OP) ::= GEQ. { OP = PMLOP_GEQ; }
cmpop(OP) ::= SLT. { OP = PMLOP_SLT; }
cmpop(OP) ::= SGT. { OP = PMLOP_SGT; }
cmpop(OP) ::= SLEQ. { OP = PMLOP_SLEQ; }
cmpop(OP) ::= SGEQ. { OP = PMLOP_SGEQ; }

borexpr(E) ::= borexpr(LHS) BOR bxorexpr(RHS). {
	E = pml_binop_alloc(PMLOP_BOR, LHS, RHS); 
}
borexpr(E) ::= bxorexpr(BX). { E = BX; }

bxorexpr(E) ::= bxorexpr BXOR bandexpr(RHS). {
	E = pml_binop_alloc(PLMOP_BXOR, LHS, RHS); 
}
bxorexpr(E) ::= bandexpr(BA). { E = BA; }

bandexpr(E) ::= bandexpr(LHS) AMP addexpr(RHS). {
	E = pml_binop_alloc(PMLOP_BAND, LHS, RHS); 
}
bandexpr(E) ::= addexpr(A). { E = A; }

addexpr(E) ::= addexpr(LHS) PLUS mulexpr(RHS). {
	E = pml_binop_alloc(PMLOP_PLUS, LHS, RHS); 
}
addexpr(E) ::= addexpr(LHS) MINUS mulexpr(RHS). {
	E = pml_binop_alloc(PMLOP_MINUS, LHS, RHS); 
}
addexpr(E) ::= mulexpr(M). { E = M; }

mulexpr(E) ::= mulexpr(LHS) TIMES shiftexpr(RHS). {
	E = pml_binop_alloc(PMLOP_TIMES, LHS, RHS); 
}
mulexpr(E) ::= mulexpr(LHS) DIV shiftexpr(RHS). {
	E = pml_binop_alloc(PMLOP_DIV, LHS, RHS); 
}
mulexpr(E) ::= mulexpr(LHS) MOD shiftexpr(RHS). {
	E = pml_binop_alloc(PMLOP_MOD, LHS, RHS); 
}
mulexpr(E) ::= shiftexpr(S). { E = S; }

shiftexpr(E) ::= shiftexpr(LHS) shiftop(OP) uexpr(RHS). {
	E = pml_binop_alloc(OP, LHS, RHS); 
}
shiftexpr(E) ::= uexpr(U). { E = U; }

shiftop(OP) ::= SHL. { OP = PMLOP_SHL; }
shiftop(OP) ::= SHR. { OP = PMLOP_SHR; }
shiftop(OP) ::= SHRA. { OP = PMLOP_SRA; }

uexpr(E) ::= NOT pexpr(PE). { E = pml_unop_alloc(PMLOP_NOT, PE); }
uexpr(E) ::= BINV pexpr(PE). { E = pml_unop_alloc(PMLOP_BINV, PE); }
uexpr(E) ::= MINUS pexpr(PE). { E = pml_unop_alloc(PMLOP_NEG, PE); }
uexpr(E) ::= pexpr(PE). { E = PE; }

pexpr(PE) ::= LPAREN expr(E) RPAREN. { PE = E; }
pexpr(PE) ::= funcall(FC). { PE = (union pml_expr_u *)FC; }
pexpr(PE) ::= value(V). { PE = (union pml_expr_u *)V; }

funcall(F) ::= ID(N) LPAREN exprlist(A) RPAREN. { 
	struct pml_function *f;
	char *name = N.u.raw.data;
	f = pml_ast_lookup_func(ast, name); 
	if (f == NULL) {
		pml_ast_err(ast, "Undefined function: %s\n", name);
		ast->pmla_error = 1;
	}
	free(name);
	F = (struct pml_funcall *)pml_alloc(PMLTT_FUNCALL);
	F->pmlfc_func = f;
	F->pmlfc_args = A;
}
funcall(F) ::= ID(N) LPAREN RPAREN. { 
	struct pml_function *f;
	char *name = N.u.raw.data;
	f = pml_ast_lookup_func(ast, name);
	if (f == NULL) {
		pml_ast_err(ast, "Undefined function: %s\n", name);
		ast->pmla_error = 1;
	}
	free(name);
	F = (struct pml_funcall *)pml_alloc(PMLTT_FUNCALL);
	F->pmlfc_func = f;
	F->pmlfc_args = (struct pml_list *)pmlt_alloc(PMLTT_LIST);
}
exprlist(EL1) ::= exprlist(EL0) COMMA expr(E). { 
	l_ins(&EL0->pmll_ln, &E->node->pmln_ln);
	EL1 = EL0;
}
exprlist(EL) ::= expr(E). { 
	struct pml_list *l = (struct pml_list *)pmlt_alloc(PMLTT_LIST);
	l_ins(&l->pmll_ln, &E->node->pmln_ln);
	EL = l;
}

value(V) ::= var(VAR). { V = (union pml_expr_u *)VAR; }
value(V) ::= AMP locator(VAR). { V = (union pml_expr_u *)VAR; }
value(V) ::= BYTESTR(I). {
	V = (struct pml_value *)pmlt_alloc(PMLTT_BYTESTR);
	pml_bytestr_set_dynamic(&V->pmlv_byteval, I.u.raw.data, I.u.raw.len);
}
value(V) ::= IPADDR(I). {
	V = (struct pml_value *)pmlt_alloc(PMLTT_BYTESTR);
	pml_bytestr_set_static(&V->pmlv_byteval, I.u.v4addr, 4);
}
value(V) ::= IPV6ADDR(I). {
	V = (struct pml_value *)pmlt_alloc(PMLTT_BYTESTR);
	pml_bytestr_set_static(&V->pmlv_byteval, I.u.v6addr, 16);
}
value(V) ::= ETHADDR(I). {
	V = (struct pml_value *)pmlt_alloc(PMLTT_BYTESTR);
	pml_bytestr_set_static(&V->pmlv_byteval, I.u.ethaddr, 6);
}
value(V) ::= numval(N). { V = N; }
value(V) ::= STRING(I). {
	V = (struct pml_value *)pmlt_alloc(PMLTT_BYTESTR);
	pml_bytestr_set_dynamic(&V->pmlv_byteval, I.u.raw.data, I.u.raw.len);
}

var(V) ::= locator(L). { V = L; }
var(V) ::= locator(N) LBRACKET borexpr(PK) COMMA borexpr(O) COMMA borexpr 
	   RBRACKET(L). {
	N->pmlloc_pkt = PK;
	N->pmlloc_off = O;
	N->pmlloc_len = L;
	V = N;
}
var(V) ::= locator(N) LBRACKET borexpr(O) COMMA borexpr(L) RBRACKET. {
	N->pmlloc_off = O;
	N->pmlloc_len = L;
	V = N;
}

locator(L1) ::= locator(L0) DOT ID(TOK). {
	if (pml_loc_extend_name(L0, TOK.u.raw.data, TOK.u.raw.len) < 0) {
		pml_ast_err(ast, "Out of memory for space.\n");
		ast->pmla_error = 1;
	}
	free(TOK.u.raw.data);
	L0 = L1;
}
locator(L) ::= ID(TOK). { 
	L = pmlt_alloc(PMLTT_LOCATION);
	L->pmlloc_name = TOK.u.raw.data;
}

numval(N) ::= NUM(TOK). {
	N = (struct pml_value *)pmlt_alloc(PMLTT_SCALAR);
	N->pmlv_sval = TOK.u.num;
	N->pmlv_swidth = 4;
}
