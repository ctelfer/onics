/*
 * ONICS
 * Copyright 2012-2022
 * Christopher Adam Telfer
 *
 * protoparse.h -- API for manipulating protocol parses.
 *
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef __prototparse_h
#define __prototparse_h
#include <cat/cat.h>
#include <cat/list.h>
#include "prid.h"

/*
   A PRID_NONE type parse just represents a parsed region of a buffer that
   is its own unit.  (e.g. a packet, a SSL record, etc..)  The header
   and trailer represents unused slack space in the region.  It gets updated
   on any header adjustment for enclosed PDUs.
*/

#define PDU_ERR_TOOSMALL        0x0001
#define PDU_ERR_HLEN            0x0002
#define PDU_ERR_TRUNC           0x0004
#define PDU_ERR_CKSUM           0x0008
#define PDU_ERR_OPTLEN          0x0010
#define PDU_ERR_OPTERR          0x0020
#define PDU_ERR_INVALID         0x0040	/* invalid combination of options */
#define PDU_ERR_MAXBIT		6

#define PDU_ERR_HLENMASK        (PDU_ERR_TOOSMALL|PDU_ERR_HLEN)

struct pdu;

/*
 * This structure is used as a bare-bones specification for a PDU.
 * The protoparse library can request a protocol parser to generate such
 * a specification (see the proto_parser_ops getspec() function).
 * Alternately, a user can provide a specification directly and request that
 * the protocol parser create the PDU accordingly.  The specification
 * basically contains the protocol ID, the starting offset within some
 * buffer for the PDU, and the length of the 3 main parse regions:
 * header, payload and trailer.  (any of which may be 0)
 */
struct pduspec {
	uint			prid;
	ulong			off;
	ulong			hlen;
	ulong			plen;
	ulong			tlen;
};


/*
 * This is the main interace for a protocol parser.  A protocol parser
 * must implement all 4.  Each function sets errno when they fail with
 * an error of some sort.
 */
struct proto_parser_ops {

	/*
	 * Parse a blob of data that either file information or another
	 * protocol parser has identified as being a PDU of this
	 * type of protocol.  Return the new parse on success or NULL
	 * on an error, setting errno appropriately.
	 *
	 * Parameters:
	 * + reg  -- the parent region enclosing this blob of data.
	 *           Usually the encapsulating protocol if one exists.
	 * + buf  -- a pointer to the buffer containing the PDU.
	 * + off  -- The offset of the start of the PDU within the buffer.
	 * + maxlen -- The maximum length that this PDU might be starting
	 *             from off.
	 *
	 * Returns a new PDU for the library to insert into the list of
	 * PDUs or NULL on an error.
	 */
	struct pdu * (*parse)(struct pdu *reg, byte_t *buf, ulong off,
			      ulong maxlen);

	/*
	 * Determine the protocol of the next PDU ia buffer of data based
	 * on information from known PDUs.  The parsing library calls
	 * this function passing in an existing PDU generated by this parser.
	 * It also passes in the last child of that PDU or NULL if the PDU
	 * has no children.  This function must then return a protocol ID
	 * of the protcol that follows this child in within the region, the
	 * starting offset of the PDU and the maximum length that that PDU
	 * can occupy.
	 *
	 * Parameters:
	 * + reg  -- The encapsulating region of the PDU.
	 * + buf  -- The buffer containing the PDU.
	 * + cld  -- The last child of 'reg' created or NULL if it has none.
	 * + prid -- A pointer to hold protocol ID of the next PDU.
	 * + off  -- A pointer to hold the starting offset of the next PDU.
	 * + maxlen -- A pointer to hold the maximum length of the next PDU.
	 *
	 * Returns 0 if there are no further identifiable PDUs in this
	 * region according to this protocol parser.  Returns 1 if the parser
	 * was able to identify a PDU.  In this case, 'prid', 'off' and
	 * 'maxlen' will all be set.  Otherwise their values are undefined.
	 */
	int (*nxtcld)(struct pdu *reg, byte_t *buf, struct pdu *cld,
		      uint *prid, ulong *off, ulong *maxlen);

	/*
	 * Generate a specification (struct pduspec) for a PDU for this
	 * protocol.  The new PDU would either enclose an existing PDU or
	 * would be encapsulated within an existing PDU.
	 *
	 * Parameters:
	 * + pdu  -- the PDU to either enclose in a new PDU or create a
	 *           new child PDU of depending on the 'enclose' parameter.
	 * + enclose -- if non-zero generate a specification for a PDU
	 *              enclosing the region of 'pdu'.  Otherwise generate
	 *              a spec for embeddeding a new PDU within the region
	 *              of 'pdu'.
	 * + ps  -- The new specification, suitable for the add funtion.
	 *
	 * Returns 0 if successful and -1 on a failure setting errno
	 * appropriately.
	 */
	int (*getspec)(struct pdu *pdu, int enclose, struct pduspec *ps);

	/*
	 * Create a new PDU with offsets based on a specification
	 * and insert it into the PDU chain.  The new PDU will either enclose
	 * the 'reg' parse or will be enclosed by it depending on the 'enclose'
	 * parameter.  If the 'buf' parameter is not NULL, then the function
	 * must also initialize the PDU data to with default values sufficient
	 * for an error free parsing.
	 *
	 * Paramters:
	 * + reg  -- the PDU to either enclose the new parse or be enclosed
	 *           by the new PDU.  Will never be the outermost PDU if
	 *           'enclose' is non-zero.
	 * + buf  -- a buffer to hold actual PDU data.  This parameter
	 *           can be NULL.  The function should still create a
	 *           new PDU based on the specification in this case.
	 * + ps  -- The specification for the new PDU. This will contain
	 *          offsets with 'buf' (if 'buf' is not NULL) and lengths
	 *          for header, payload and trailer regions.
	 * + enclose -- If set to non-zero the the new PDU should enclose
	 *              the 'reg' PDU.  Otherwise, 'reg' should be set to
	 *              enclose the new PDU.
	 *
	 * Returns 0 on success and -1 on failure setting errno appropriately.
	 */
	int (*add)(struct pdu *reg, byte_t *buf, struct pduspec *ps,
		   int enclose);
};


/*
 * A structure for a protocol parser used internally.
 */
struct proto_parser {
	uint			prid;
	uint			valid;
	struct proto_parser_ops *ops;
};

/*
 * Install a protocol parser to handle a particular protocol type.
 * Returns 0 on success or -1 on error setting errno appropriately.
 */
int pp_register(uint prid, struct proto_parser_ops *ops);

/*
 * Find a protocol parser by protocol ID.
 *
 * Returns the protocol parser or NULL on failure.
 */
const struct proto_parser *pp_lookup(uint prid);

/*
 * Unregister the protocol parser by protocol ID.
 *
 * Returns 0 on success and -1 on failure.
 */
int pp_unregister(uint prid);



/*
 * This is a table of function pointers that the protocol parser populates
 * in every PDU it instantiates.  It basically encompasses the
 * operations that every PDU should be able to carry out on its packet data.
 */
struct pdu_ops {
	/*
	 * Re-parse the PDU using the same bounds for the PDU that are in
	 * 'pdu' and update the fields PDU.
	 *
	 * Parameters:
	 * + pdu  -- The pdu to update.
	 * + buf  -- The buffer that contains the actual PDU data.
	 */
	void (*update)(struct pdu *pdu, byte_t *buf);

	/*
	 * Fix the field(s) of this PDU data (if any) indicating the 'next'
	 * protocol/header/etc according to the PRID of the next PDU.
	 * Adjust the checksum according to the changes if applicable.
	 *
	 * Parameters:
	 * + pdu  -- The parse referring to the PDU whose 'next field' to fix.
	 * + buf  -- The buffer containing the actual PDU data.
	 *
	 * Returns 0 on success and -1 on error setting errno appropriately
	 */
	int (*fixnxt)(struct pdu *pdu, byte_t *buf);

	/*
	 * Fix the length field(s) (if any) in this PDU's data according to the
	 * header/payload/trailer/etc... values in 'pdu'.
	 *
	 * Parameters:
	 * + pdu  -- The parse referring to the PDU whose length to fix.
	 * + buf  -- The buffer containing the actual PDU data.
	 *
	 * Returns 0 on success and -1 on error setting errno appropriately
	 */
	int (*fixlen)(struct pdu *pdu, byte_t *buf);

	/*
	 * Fix the checksum field(s) (if any) in this PDU's data.
	 *
	 * Parameters:
	 * + pdu  -- The parse referring to the PDU whose length to fix.
	 * + buf  -- The buffer containing the actual PDU data.
	 *
	 * Returns 0 on success and -1 on error setting errno appropriately.
	 */
	int (*fixcksum)(struct pdu *pdu, byte_t *buf);

	/*
	 * Copy a PDU and return the copy.
	 *
	 * Parameters:
	 * + pdu  -- The pdu to copy.
	 *
	 * Returns the new pdu or NULL on an error setting errno appropriately.
	 */
	struct pdu * (*copy)(struct pdu *pdu);

	/*
	 * Free a protocol parse and its associated state.
	 *
	 * Parameters:
	 * + pdu  -- The protocol parse to free.
	 */
	void (*free)(struct pdu *pdu);
};


/*
 * Start of
 * Packet Buffer
 * |                    Encapsulating PDUs
 * |     par.poff                                                par.toff
 * | ...----+-------------------------------------------------------+----...
 * |        |  pdu.soff    pdu.poff             pdu.toff  pdu.end   |
 * | header |      +---------+---------------------+---------+      | trailer
 * |        |      | header  | payload             | trailer |      |
 * |        |      +---------+---------------------+---------+      |
 * |        |      A         B    ^                C         D      |
 * | ...----+---------------------)---------------------------------+----...
 * |        \_____/               |                          \_____/
 *             |                  |                             |
 *       may be 0-length     possible encapsulated        may be 0-length
 *                           packet contained here
 */

/*
 * A 'pdu' structure denotes a decode of the region of a protocol as well
 * as decode of its various fields.  All PDUs at a minimum have a starting
 * offset, a header, payload and trailer fields.  All of these are have an
 * offset in bytes.  The length of a field can be 0.  The PDUs associated with
 * a particular buffer are ordered by their start offsets.  So, if the
 * header or trailer offset of a PDU change, the PDU may have to be
 * moved in the list.
 */

/*
 * A note for IPv6 and IPsec.  When an IPv6 packet has an ESP or AH header,
 * that header is considered the start of the payload of the v6 packet.
 * This is a specific example where the abstraction of encapsulating PDUs
 * breaks down.  IPsec is, in many ways, its own set of protocols that
 * encapuslate data.  It is convenient to treat them as such.  However, IPv6
 * destination options CAN come after the IPsec headers.  In the case of ESP
 * with encryption, this is not data that we can parse anyways.  Nevertheless
 * this won't always be the case.  Given this kind of "call" on how to
 * interpret the fields, the "payload offset" is, therefore, the first byte
 * of the protocol unit that isn't the purview of the encapsulating protocol.
 * This does NOT always mean that there can't be protocol relevant bytes
 * in the payload section.  But it won't typically be the case.
 */


#define PDU_OI_SOFF 0
#define PDU_OI_POFF 1
#define PDU_OI_TOFF 2
#define PDU_OI_EOFF 3
#define PDU_OI_MIN_NUM 4
#define PDU_OI_EXTRA PDU_OI_MIN_NUM
#define PDU_OI_INVALID ((uint)-1)
#define PDU_OFF_INVALID ((ulong)-1)
#define PDU_OFF_MAX (((ulong)-1) - 1)


/*
 * This structure represents a parse of a PDU.  Each parse contains
 * at least 4 offsets for the start of the PDU, the start of the
 * payload, the start of the trailer and the end of the packet.
 * The parse may also have further offsets beyond this.  That is:
 * noff >= 4 in a well-formed parse.  The protocol parser itself
 * is responsible for ensuring that sufficient memory is allocated
 * to contain the additional offsets plus any private state it
 * wishes to maintain.
 */
struct pdu {
	uint			prid;		/* protocol ID of the PDU */
	uint			error;		/* bitmap of PDU_ERR_* */
	struct pdu_ops *	ops;		/* table of parse func ptrs */
	struct list		node;		/* linked list node */
	struct pdu *		region;		/* the enclosing region */
	uint			noff;		/* # of parse offsets (>=4) */
	ulong			offs[PDU_OI_MIN_NUM];	/* the parse offsets */
};
#define pdu_soff(_pdu) ((_pdu)->offs[PDU_OI_SOFF])
#define pdu_poff(_pdu) ((_pdu)->offs[PDU_OI_POFF])
#define pdu_toff(_pdu) ((_pdu)->offs[PDU_OI_TOFF])
#define pdu_eoff(_pdu) ((_pdu)->offs[PDU_OI_EOFF])
#define pdu_hlen(_pdu) (pdu_poff(_pdu) - pdu_soff(_pdu))
#define pdu_plen(_pdu) (pdu_toff(_pdu) - pdu_poff(_pdu))
#define pdu_tlen(_pdu) (pdu_eoff(_pdu) - pdu_toff(_pdu))
#define pdu_totlen(_pdu) (pdu_eoff(_pdu) - pdu_soff(_pdu))
#define pdu_header(_pdu, _buf, _type) \
	((_type *)((byte_t *)(_buf) + pdu_soff(_pdu)))
#define pdu_payload(_pdu, _buf) ((byte_t *)(_buf) + pdu_poff(_pdu))
#define pdu_trailer(_pdu, _buf, _type) \
	((_type *)((byte_t *)(_buf) + pdu_toff(_pdu)))
#define pdu_prev(_pdu) container((_pdu)->node.prev, struct pdu, node)
#define pdu_next(_pdu) container((_pdu)->node.next, struct pdu, node)
#define pdu_is_root(_pdu) ((_pdu)->region == NULL)
#define pdu_list_head(_pdu) pdu_is_root(_pdu)
#define pdu_list_end(_pdu) pdu_is_root(_pdu)
#define pdu_empty(_pdu) (l_isempty(&(_pdu)->node))
#define pdu_off_valid(_pdu, _off) \
	( ((uint)(_off) < (_pdu)->noff) && \
	  ((_pdu)->offs[(uint)(_off)] != PDU_OFF_INVALID) )

#define pdu_for_each(_pdu, _plist)		\
	for ((_pdu) = pdu_next(_plist) ;	\
	     !pdu_list_head(_pdu) ;		\
	     (_pdu) = pdu_next(_pdu))

#define pdu_for_each_safe(_pdu, _x_plist)			\
	for ((_pdu) = pdu_next(_plist), (_x) = pdu_next(_pdu) ;	\
	     !pdu_list_head(_pdu) ;				\
	     (_pdu) = (_x), (_x) = pdu_next(_pdu))

/*
 * Find the root region for this PDU.  This is the root node of the
 * of the parse tree and the parent of all other PDUs for a given
 * block of data (usually the whole packet in a buffer).
 */
struct pdu *pdu_get_root(struct pdu *pdu);

/*
 * Find the next PDU in the specified region or return NULL if none
 * exists in the parse list.  Use the region PDU as the 'from' for
 * to start at the beginning of a region.  NOTE, that on its own, this
 * does not find subregions within the region.  One can use a recursive
 * or even iterative process with this function to walk all sub regions
 * as well.  Recursive is more elegant.  :)
 *
 * Recursive example:
 * walk(from, reg) {
 *   next = pdu_next_in_region(from, reg);
 *   if (next != NULL) {
 *     ** do X with pdu **
 *     walk(next, next);
 *     walk(next, reg);
 *   }
 * }
 *
 * Iterative example:
 * curreg = reg;
 * pdu = pdu_next_in_region(reg, reg);
 * while ( pdu != NULL ) {
 *   ** do whatever with pdu **
 *   pdu2 = pdu_next_in_region(pdu, pdu);
 *   if ( pdu2 != NULL ) {
 *     curreg = pdu;
 *     pdu = pdu2;
 *   } else {
 *     do {
 *       pdu2 = pdu_next_in_region(pdu, curreg);
 *       if (pdu2 == NULL) {
 *         ** done with this region, go up one **
 *         curreg = pdu->region;
 *       } else {
 *         pdu = pdu2;
 *       }
 *     } while ( pdu == NULL && curreg != reg->region );
 *   }
 * }
 */
struct pdu *pdu_next_in_region(struct pdu *from, struct pdu *reg);

/* returns 1 if a region contains no parses that refer to it */
int pdu_region_empty(struct pdu *reg);

/*
 * Initializes a fresh PDU of PRID_NONE.  This can be used to create the
 * root for a full PDU tree.
 */
void pdu_init_root(struct pdu *head, ulong len);

/* Insert a PDU into set of parsed PDUs */
void pdu_insert(struct pdu *from, struct pdu *toins);

/* remove a PDU from a set of parsed PDUs */
void pdu_remove(struct pdu *pdu);

/*
 * Given an initialized PDU root for a buffer (PRID_NONE) and
 * an initial protocol id, parse the packet and add to the list
 * of PDUs.  Returns -1 on an allocation error.  Otherwise, parse errors
 * (which may be acceptable for certain applications) are stored in the
 * error fields of the generated PDUs.
 */
int pdu_parse_packet(struct pdu *root, byte_t *buf, uint firstprid);

/*
 * Populate a default PDU specification based on either enclosing
 * the given PDU or inserting the spec within the payload of the
 * PDU. (based on the 'enclose' parameter.  If the function returns 0,
 * then the spec is poulated with values appropriate to pass to pdu_add().
 */
enum {
	PDU_GSF_APPEND,
	PDU_GSF_WRAPPDU,
	PDU_GSF_WRAPPLD,
};
int pdu_get_spec(uint prid, struct pdu *pdu, int flags, struct pduspec *ps);

/*
 * Create a new PDU in a parsed packet.  The pduspec specifies the
 * type and location of the PDU.  'reg' is the enclosing region for
 * the PDU.  Note that means one can not use pdu_add() to generate an
 * outermost PDU. If the 'buf parameter is not NULL the operation
 * will also create a 'default' packet data (e.g. header) in the buffer at the
 * offsets indicated by the pduspec.  If enclose is non-zero, then the
 * operation will search for outermost PDU in 'reg' that fall within the
 * new PDU's region and reassign them to refer to the new PDU as their
 * region.
 */
int pdu_add(struct pdu *reg, byte_t *buf, struct pduspec *ps, int enclose);

/*
 * Free a complete PDU parse tree.  pdu->region == NULL  This does not free
 * the PDU root itself.
 */
void pdu_clear(struct pdu *pdu);

/*
 * Free a single PDU .  All sub regions of the PDU are made part of PDU's
 * parent region.  It is an error to call this on the root region.  This
 * does nothign to the packet data that the PDU referred to.
 */
void pdu_free_parse(struct pdu *pdu);

/*
 * Free a PDU, and all child headers.  If called on the root PDU
 * then this is equivalent to pdu_clear()
 */
void pdu_free_region(struct pdu *pdu);

/* copy a PDU (but not the packet buffer itself). */
int pdu_copy(struct pdu *npdu, struct pdu *opdu);

/*
 * re-parse and update the fields in 'pdu'.  (but not its children)
 * returns error field as a matter of convenience
 */
uint pdu_update(struct pdu *pdu, byte_t *buf);

/* fix the "next header" field in a given PDU to the enclosed PDU */
int pdu_fix_nxthdr(struct pdu *pdu, byte_t *buf);

/* fix up checksums in the 'pdu' protocol header */
int pdu_fix_cksum(struct pdu *pdu, byte_t *buf);

/*
 * fix up length fields in the 'pdu' protocol header based on 'pdu'
 * protocol metadata
 */
int pdu_fix_len(struct pdu *pdu, byte_t *buf);

/*
 * Insert data into the packet and adjust PDUs.  The starting byte
 * S = pdu_soff(pdu) + off.  That is, the 'off'th byte after the start of
 * the PDU.  if moveup is nonzero, then the function shifts bytes [S,end]
 * 'len' bytes forward in the packet and fills them with dummy values.  If
 * 'moveup' is zero, then it shifts bytes [0,S-1] down 'len' bytes and
 * the new space is filled with dummy values.  When 'moveup' is nonzero,
 * all offsets >= S are increased by 'len'.  When 'moveup' is zero, all
 * offsets < S are decreased by 'len'.  This function does not change offsets
 * set to PDU_OFF_INVALID.  It is illegal to specify a starting offset
 * before the payload offset or after the trailer offset of the outermost
 * PDU.  (i.e. the outer PRID_NONE start and end).  This function will
 * move those offsets, however depending on the value of 'moveup'.
 */
int pdu_inject(struct pdu *pdu, byte_t *buf, ulong off, ulong len,
	       int moveup);

/*
 * Remove data from a packet and adjust PDUs.  The starting byte is
 * S = pdu_soff(pdu) + off.  That is, the 'off'th byte after the start
 * of the PDU.  if 'moveup' is non-zero then pdu_cut() shfts bytes [0,S-1]
 * len bytes forward and increments all PDU offsets less than S
 * by 'len'.  If 'moveup' is zero then pdu_cut() shifts bytes [S+len,end]
 * down to byte position S, and decrements all offsets >= S+len by 'len'.
 * pdu_cut() does not move PDU_OFF_INVALID offsets.  offsets falling within
 * range of removed bytes are set to S. It is illegal to cut bytes that are
 * outside of the region [poff,toff] of the outermost PDU. (i.e. the
 * outer PRID_NONE start and end).  This function will move those offsets
 * however, depending on the value of 'moveup'.
 */
int pdu_cut(struct pdu *pdu, byte_t *buf, ulong off, ulong len, int moveup);

/*
 * expand or contract header/trailer within the encapsulating space
 * Note that an offset adjustment can't overrun its adjacent offsets.
 * pdu_adj_plen() moves both the trailer offset and ending offset in unison.
 * It basically acts as shorthand for a common case of adding or chopping
 * payload to a particular packet.
 */
int pdu_adj_off(struct pdu *pdu, uint oid, long amt);/* adjust an offset */
int pdu_adj_plen(struct pdu *pdu, long amt);	/* adjust C+D */

/*
 * Adjust a region so that its payload starts on the first used byte at the
 * beginning and it's trailer starts on first unused byte at the end.  A byte
 * is "used" if it falls within some parse within the region or a dependent
 * sub region.
 */
int pdu_adj_unused(struct pdu *pdu);

/*
 * Internal call for use by protocol parse libraries to insert a newly
 * created parse into a region and set it appropriately.  (for pdu_add()
 * calls.)
 */
void pdu_add_insert(struct pdu *reg, struct pdu *toadd, int enclose);


/*
 * Initialize a PDU.  (Used by protocol libraries)
 */
void pdu_init(struct pdu *pdu, uint prid, ulong off, ulong hlen, ulong plen,
	      ulong tlen, struct pdu_ops *ops, struct pdu *reg,
	      uint nxfields);

/* Reset all the extra fields in a parse */
void pdu_reset_xfields(struct pdu *pdu);


/* Initialize a pduspec based on a region we are either trying to */
/* enclose or fit the header within. */
int pduspec_init(struct pduspec *ps, struct pdu *pdu, uint prid, uint hlen,
		 uint tlen, int enclose);

/* No-op versions of the pdu operations for protocol parsers */
void pdu_nop_update(struct pdu *pdu, byte_t *buf);
int pdu_nop_fixnxt(struct pdu *pdu, byte_t *buf);
int pdu_nop_fixlen(struct pdu *pdu, byte_t *buf);
int pdu_nop_fixcksum(struct pdu *pdu, byte_t *buf);
struct pdu *pdu_nop_copy(struct pdu *opdu);
void pdu_nop_free(struct pdu *pdu);

#endif /* __protoparse_h */
