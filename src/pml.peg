/*
 * ONICS
 * Copyright 2017
 * Christopher Adam Telfer
 *
 * pml.peg -- Parser for the PML programming language.
 *
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * compile with
 *  # pegcc -o pmlp -p pml_peg
 *  # gcc -c pmlp.c -Ipath/to/catlib/include
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <errno.h>
#include <ctype.h>
#include <cat/cat.h>
#include <cat/list.h>
#include <cat/str.h>
#include <cat/inport.h>
#include <cat/stdclio.h>
#include <cat/emalloc.h>
#include <cat/err.h>
#include "onics_config.h"
#include "pmltree.h"
#include "pmlparse.h"
#include "ns.h"


/*
Language summary:

# COMMENT

?- tcp.sport == tcp.ports.http -?

# Match operator is =~, inverse is !~
# Takes field on one side, pattern other
# Patterns include:
#   IP[v6] w/ mask, bytestring w/ mask, eth addr w/ mask,
#   regex, numeric range
#
?- ip.saddr =~ 127.0.0.0/24 -?          # IP w/mask
?- eth.saddr !~ c0:2a:f9:00:00:00/ff:ff:ff:f0:00:00 -?  # eth addr
?- not (pkt.data =~ "hello world!") -?  # ascii string match
?- not (pkt.data !~ \xa5a6a7a8a9aaabac) -?  # byte string match
?- pkt.data =~ `hello +world!` -?       # regex
?- ipv6.daddr =~ ff80:abcd::/8 -?	# ipv6 w/mask
?- tcp.dport !~ tcp.ports.reserved -?   # numeric range
?- udp.sport !~ [0..1023] -?		# numeric range
?- tcp[2,10] =~ \xABCDEF0123DEADBEEF01/FEEDA110FFFFFFFFAB -? # bytes w/ mask

# Short circuiting boolean ops are supported of course
?- eth && ip6 && pkt.len > ip6.len + 40 + 14 -?

?- pop(tcp.flags == 2) -?

?- nlz(ip6.flowid) == 4 -?

?- tcp[2,2] == 1628 -?

# byte 3 in the second IP header in the first packet
?- $(0,1)ip[3,1] == 65 -?

# compares as 64-bit integer
?- eth.saddr == 5 -?

# compares first 8 bytes as 64-bit integer
# probably not intended
?- ipv6.saddr == 5 -?

# A inline function that calls only other inline functions and is not
# directly or indirectly recursive.  It's body is a single expression.
inline ishttp() ( tcp && (tcp.sport == 80 || tcp.dport == 80) )

# A function can be recursive, have local variables and it has
# a series of statements enclosed in braces.
int incr(v) {
	x = v + 1;
	return x;
}

int Count;

# Patterns can call inline functions.
?- ishttp() -? { Count = incr(Count); }

*/


/*

  Variables -- all local variables are 64 bit signed numbers (for now)
  Local variables are referred to by name


  Abstractions:
   - PRID == protocol ID, identifies a parsable protocol
   - PKID == packet ID, identifies one of the 16 packets in the working set
   - FLD == field, a unit of data that has meaning within a protocol
            There are 2 data types of fields:
	      - bit fields - width <= 32 bits and do not start at byte offsets
	      - byte string - Starts at a byte offset, and can have any width.
	            data within the field can be interpreted in any desired
		    way.
		    * byte strings of 8 or less bytes can be operated on as
		      numeric values.

  Notation:
   a			-- Variable name (global or local) or proto name
   @<protoname>		-- Protocol ID (scalar)
   a.b.c.d		-- Field for packet 0 or protocol constant
   a.b.c.d[o,l]		-- Bytes from packet 0, field a.b.c.d, offset o length l
   $(p)a.b.c.d[o,l]	-- Bytes from packet p, field a.b.c.d, offset o length l
   $(p,i)a.b.c.d[o,l]	-- Bytes from packet p, i'th 'a' header, field a.b.c.d,
			   offset o length l

  Intrinsic Functions:
   - Drop
   - Fix datalink type
   - Insert space
   - Cut space
   - Duplicate
   - Push header inner or outer
   - Pop header inner or outer
   - Update header
   - Fix lengths
   - Fix checksum
   - Send packet
   - (Un)Set layer
   - pop(ulation count)
   - nlz (number of leading zeroes)
   - signext (sign extend a value)

  Statements:
   - Any expression (including function calls)
   - if then else
   - while
   - assignment (=)
   - print
   - return

  Variable declarations:
    <type> <name> ;
    <type> <name> = <init> ;
    str <name>[<len>] ;
    str <name>[<len>] = <init> ;   # Global only

    <type> can be:  int, str
    - int is a 64-bit signed integer
    - str is a reference to a byte string
    - Declaration with length is only permitted in global declarations
      and declares a globally accessible byte string.

  Function declarations:
    <type> <name> ( <args> ) { <body> }

    int fib(int x) {
	if (x < 2)
		return 1;
	else
		return fib(x-1) + fib(x-2);
    }

  Rule declarations:
   - ?- <pat> -? { <action> }
   - { <action> }
   - BEGIN { <action> }
   - TICK { <action> }
   - END { <action> }
*/


/* ----- Basic Declarations ----- */

struct pml_peg_parser;


struct pml_stack_entry {
	int pse_type;
	union {
		void *ptr;
		ulong ival;
	} pse_u;
};
#define pse_ptr	      pse_u.ptr
#define pse_int       pse_u.ival

enum {
	PSE_TYPE_INVALID = 0,
	PSE_TYPE_NODE,
	PSE_TYPE_PTR,
	PSE_TYPE_INT,
};


#define PML_LIB_PATH	"lib/pml"
#define DEFAULT_PATH	"."
#define NEXTCEOF	-1

enum {
	NTYPE, FTYPE, STYPE
};


struct inputs {
	struct list			ln;
	int				type;
	ulong				lineno;
	union {
		struct cstr_inport	csi;
		struct file_inport	fi;
	} inp_u;
	struct inport *			inp;
	char				name[256];
};
#define l_to_input(_n) (container((_n), struct inputs, ln))


struct iregion {
	struct list	ln;
	char		name[256];
	ulong		nchars;
};
#define l_to_iregion(_n) container((_n), struct iregion, ln)


#define MAXSTACK 65536
struct pml_parser {
	struct pml_peg_parser *	pegp;
	struct pml_ast *	ast;
	char 			ipath[512];
	struct inputs		inputs;
	struct inputs *		last_input;
	struct list 		chmap;
	pmlp_eoi_f		eoicb;
	struct pml_stack_entry	stack[MAXSTACK];
	uint			sp;
	uint			echar;
	char			errbuf[256];
};

#define INLIST(_pmlp) (&(_pmlp)->inputs.ln)
#define CURINPUT(_pmlp) (l_to_input(l_head(INLIST(_pmlp))))
#define NOINPUT(_pmlp, _pi) (&(_pi)->ln == INLIST(_pmlp))


static int nextc(void *pmlp);
static void popinput(struct pml_parser *pmlp);


static void _err(struct pml_parser *p, const char *s);
static struct pml_stack_entry *_push(struct pml_parser *p, int type,
				     const char *file, uint line);
static struct pml_stack_entry *_pop(struct pml_parser *p, int type,
				     const char *file, uint line);
static struct pml_stack_entry *_top(struct pml_parser *p, int type,
				     const char *file, uint line);


#define _ERR(_s)do { _err(PMLP, (_s)); return -1; } while (0)

#define _PUSH_PTR(_val, _type, _err_test)				\
	do {								\
		struct pml_stack_entry *pse;				\
		void *_hold = (_val);					\
		if (_err_test(_hold)) return -1;			\
		pse =_push(PMLP, (_type), __FILE__, __LINE__);	\
		if (pse == NULL) return -1;				\
		pse->pse_ptr = (_hold);					\
	} while (0)

#define _PUSH_INT(_val)							\
	do {								\
		struct pml_stack_entry *pse;				\
		pse =_push(PMLP, PSE_TYPE_INT, __FILE__, __LINE__);	\
		if (pse == NULL) return -1;				\
		pse->pse_int = (_val);					\
	} while (0)

#define _POP(_var, _ntype, _field, _rtype)				\
	do {								\
		struct pml_stack_entry *pse =				\
			_pop(PMLP, (_ntype) , __FILE__, __LINE__);	\
		if (pse == NULL)					\
			return -1;					\
		(_var) = (_rtype)pse->_field;				\
	} while (0)

#define _TOP(_var, _ntype, _field, _rtype)				\
	do {								\
		struct pml_stack_entry *pse =				\
			_top(PMLP, (_ntype) , __FILE__, __LINE__);	\
		if (pse == NULL)					\
			return -1;					\
		(_var) = (_rtype)pse->_field;				\
	} while (0)


#define NULL_TEST(_val)  ((_val) == NULL)
#define NO_ERR(_val)     0
#define PUSH_NULL_NODE() _PUSH_PTR(NULL, PSE_TYPE_NODE, NO_ERR)
#define PUSH_NODE(_val)  _PUSH_PTR(_val, PSE_TYPE_NODE, NULL_TEST)
#define POP_NODE(_var)   _POP(_var, PSE_TYPE_NODE, pse_ptr, void *)
#define TOP_NODE(_var)   _TOP(_var, PSE_TYPE_NODE, pse_ptr, void *)
#define PUSH_LIST()      PUSH_NODE(pmln_alloc(PMLTT_LIST))
#define PUSH_PTR(_val)   _PUSH_PTR(_val, PSE_TYPE_PTR, NULL_TEST)
#define POP_PTR(_var)    _POP(_var, PSE_TYPE_PTR, pse_ptr, void *)
#define TOP_PTR(_var)    _TOP(_var, PSE_TYPE_PTR, pse_ptr, void *)
#define PUSH_INT(_val)   _PUSH_INT(_val)
#define POP_INT(_var)    _POP(_var, PSE_TYPE_INT, pse_int, ulong)
#define TOP_INT(_var)    _TOP(_var, PSE_TYPE_INT, pse_int, ulong)

#define PMLP ((struct pml_parser *)pml_peg_ctx)
#define AST  (PMLP->ast)
#define TEXT pml_peg_text
#define DBG  fprintf(stderr, "%s:%d -> '%s[%lu]'\n", \
             __FILE__, __LINE__, TEXT->data, TEXT->len);

static char *_r2str(struct raw *r);
static struct raw *_ralloc(size_t len);
static struct raw *hex2str(struct raw *s);
static uint hexpairval(char *s);
static struct raw *qstr2str(struct raw *s, int qchar);
static struct raw *eth2str(struct raw *s);
static struct raw *ipv42str(struct raw *s);
static struct raw *ipv62str(struct pml_ast *ast, struct raw *s);
static struct pml_literal *atloc2value(struct pml_parser *p, char *name);
static struct pml_literal *_alloc_str(struct pml_ast *, struct raw *val,
				      int nxchars);
static ulong text2num(struct raw *r);
static struct pml_literal *_alloc_num(unsigned long val);
static struct pml_call *_alloc_call(struct pml_ast *ast, char *name,
				    struct pml_list *args);
static int push_func_hdr(struct pml_parser *pml_peg_ctx);
static int add_func_proto_or_decl(struct pml_parser *pml_peg_ctx);
static int compare_fixed_string(struct pml_parser *pmlp, int nxchars);
static int compare_masked_string(struct pml_parser *pml_peg_ctx);
static int num_to_mask(struct pml_parser *pml_peg_ctx, int bytes);
static int simple_binop(struct pml_parser *pml_peg_ctx, int op);
static int push_unop(struct pml_parser *pml_peg_ctx, int op);


%%


# Top Level Grammar

prog <- SPACING decl* { pml_ast_finalize(AST); }

decl <- import / rule / inlineDecl / constant / funcOrProtoOrGlobal_


# Declarations

import <- IMPORT '"' Filename '"' SPACING SemiOrError {
	char *filename;
	POP_PTR(filename);
	if (pmlp_open_add_infile(PMLP, filename, 1) < 0) {
		pml_ast_err(AST, "unable to open file '%s' for import",
			    filename);
		pml_peg_error = -1;
	}
	free(filename);
}


rule <- RulePattern Body_ {
	struct pml_list *body;
	struct pml_rule *rule;
	POP_NODE(body);
	POP_NODE(rule);
	rule->stmts = body;
	AST->ltab = NULL;
	if (pml_ast_add_rule(AST, rule) < 0) {
		pmln_free(rule);
		pml_peg_error = -1;
	}
}

RulePattern <- BEGIN {
	struct pml_rule *rule = pml_rule_alloc(PML_RULE_BEGIN, NULL);
	AST->ltab = &rule->vars;
	PUSH_NODE(rule);
}
/ END {
	struct pml_rule *rule = pml_rule_alloc(PML_RULE_END, NULL);
	AST->ltab = &rule->vars;
	PUSH_NODE(rule);
}
/ TICK {
	struct pml_rule *rule = pml_rule_alloc(PML_RULE_TICK, NULL);
	AST->ltab = &rule->vars;
	PUSH_NODE(rule);
}
/ PPBEGIN ExprOrError PPEND {
	union pml_expr_u *pattern;
	struct pml_rule *rule;
	POP_NODE(pattern);
	rule = pml_rule_alloc(PML_RULE_PACKET, pattern);
	AST->ltab = &rule->vars;
	PUSH_NODE(rule);
}
/ &LBRACE {
	struct pml_rule *rule = pml_rule_alloc(PML_RULE_PACKET, NULL);
	AST->ltab = &rule->vars;
	PUSH_NODE(rule);
}


inlineDecl <- INLINE Ident ParamList LBRACE ExprOrError RBraceOrError {
	struct list *t, *x;
	struct pml_function *inln;
	struct pml_list *params;
	struct pml_variable *param;

	inln = pmln_alloc(PMLTT_FUNCTION);
	inln->rtype = PML_ETYPE_SCALAR;
	inln->flags |= PML_FF_INLINE;
	POP_NODE(inln->body);
	POP_NODE(params);
	POP_PTR(inln->name);

	l_for_each_safe(t, x, &params->list) {
		inln->arity += 1;
		param = container(t, struct pml_variable, ln);
		l_rem(&param->ln);
		if (pml_func_add_param(inln, param) < 0) {
			pmln_free(param);
			pmln_free(inln);
			pml_peg_error = -1;
			break;
		}
	}
	pmln_free(params);
	if (pml_ast_add_func(AST, inln) < 0) {
		pmln_free(inln);
		pml_peg_error = -1;
	}
}


constant <- CONST Ident ASSIGN ExprOrError SemiOrError {
	struct pml_variable *v;
	char *name;
	union pml_expr_u *init;
	POP_NODE(init);
	POP_PTR(name);
	v = pml_var_alloc(name, PML_VTYPE_CONST, PML_ETYPE_SCALAR, 0, init);
	if (pml_ast_add_var(AST, v) < 0) {
		pmln_free(v);
		pml_peg_error = -1;
	}
}


VarType <- INT { PUSH_INT(PML_ETYPE_SCALAR); }
	 / STR { PUSH_INT(PML_ETYPE_STRREF); }


funcOrProtoOrGlobal_ <-
	VarType IdentOrError _funcOrProtoOrGlobalRest
	/ VOID { PUSH_INT(PML_ETYPE_VOID); } IdentOrError _funcOrProtoRest

_funcOrProtoOrGlobalRest <- &LPAREN _funcOrProtoRest / _globalVar

_funcOrProtoRest <- ParamList {
	return push_func_hdr(PMLP);
} _FuncOrProtoSwitch {
	return add_func_proto_or_decl(PMLP);
}

_FuncOrProtoSwitch <- SEMICOLON { PUSH_NULL_NODE(); } / Body_


ParamList <- LPAREN { PUSH_LIST(); } (!RPAREN Param (COMMA Param)*)?
	     RParenOrError


Param <- VarType IdentOrError {
	struct pml_list *list;
	struct pml_variable *v;
	int type;
	char *name;

	POP_PTR(name);
	POP_INT(type);
	TOP_NODE(list);
	v = pml_var_alloc(name, PML_VTYPE_PARAM, type, 0, NULL);
	l_enq(&list->list, &v->ln);
}
/ ANY { _ERR("type keyword expected"); }


_globalVar <- _GlobalRest {
	struct pml_variable *v;
	POP_NODE(v);
	if (pml_ast_add_var(AST, v) < 0) {
		pmln_free(v);
		pml_peg_error = -1;
	}
}


_GlobalRest <- SEMICOLON {
	char *name;
	int type;
	POP_PTR(name);
	POP_INT(type);
	PUSH_NODE(pml_var_alloc(name, PML_VTYPE_GLOBAL, type, 0, NULL));
}
/ ASSIGN ValueOrError SemiOrError {
	char *name;
	int type;
	union pml_expr_u *init;
	POP_NODE(init);
	POP_PTR(name);
	POP_INT(type);
	if (type == PML_ETYPE_STRREF) {
		free(name);
		pml_ast_err(AST,
			"String reference with initializer not suppported.");
		pml_peg_error = -1;
	} else {
		PUSH_NODE(pml_var_alloc(name, PML_VTYPE_GLOBAL, type, 0, init));
	}
}
/ LBRACKET _GlobalStrDecl


_GlobalStrDecl <- RBRACKET ASSIGN ValueOrError SemiOrError {
	union pml_expr_u *init;
	char *name;
	int type;
	int size;

	POP_NODE(init);
	POP_PTR(name);
	POP_INT(type);

	size = pml_find_gstr_init_size(init);
	if (size <= 0) {
		pml_ast_err(AST, "Unable to find size of global string %s",
			    name);
		pml_peg_error = -1;
	} else if (type != PML_ETYPE_STRREF) {
		pml_ast_err(AST, "non-str with \"[]\"");
		pml_peg_error = -1;
	} else {
		PUSH_NODE(pml_var_alloc(name, PML_VTYPE_GLOBAL,
				        PML_ETYPE_BYTESTR, size, init));
	}

	if (pml_peg_error < 0) {
		free(name);
		pmln_free(init);
	}
}
/ Number RBracketOrError _GlobalFixedStrDecl {
	union pml_expr_u *init;
	char *name;
	int type;
	uint size;

	POP_NODE(init);
	POP_INT(size);
	POP_PTR(name);
	POP_INT(type);

	if (type != PML_ETYPE_STRREF) {
		pml_ast_err(AST, "non-string declaration with length");
		free(name);
		pmln_free(init);
		return -1;
	}

	PUSH_NODE(pml_var_alloc(name, PML_VTYPE_GLOBAL, PML_ETYPE_BYTESTR,
				size, init));
}


_GlobalFixedStrDecl <- ASSIGN ValueOrError SemiOrError
		     / SEMICOLON { PUSH_NULL_NODE(); }


Body_ <- LBRACE { PUSH_LIST(); } localVars _StatementList RBraceOrError


localVars <- (VarType IdentOrError SemiOrError {
	char *name;
	int type;
	struct pml_variable *v;

	POP_PTR(name);
	POP_INT(type);
	v = pml_var_alloc(name, PML_VTYPE_LOCAL, type, 0, NULL);
	if (pml_func_add_var(AST->ltab, AST->livefunc, v) < 0) {
		pml_ast_err(AST, "error adding local var '%s'", name);
		pmln_free(v);
		pml_peg_error = -1;
	}
})*


# Statements

_StatementList <- _Statement*

_Statement <- _PrintStatement / Statement {
	struct pml_list *list;
	union pml_node *stmt;
	POP_NODE(stmt);
	TOP_NODE(list);
	l_enq(&list->list, &stmt->base.ln);
}


_PrintStatement <- PRINT _PrintExpr (COMMA !SEMICOLON _PrintExpr)* _PrintEnd

_PrintExpr <- PrintFmt ExprOrError {
	struct pml_print *p;
	struct pml_list *list;
	union pml_expr_u *expr;
	struct pml_print_fmt *fmt;

	POP_NODE(expr);
	POP_NODE(fmt);
	TOP_NODE(list);
	p = pml_print_alloc(expr, fmt);
	l_enq(&list->list, &p->ln);
}


PrintFmt <- !MOD { PUSH_NULL_NODE(); }
          / MOD {
	PUSH_NODE(ecalloc(sizeof(struct pml_print_fmt), 1));
} (&MINUS MINUS {
	struct pml_print_fmt *fmt;
	TOP_NODE(fmt);
	fmt->flags = PML_PFLAG_LJUST;
})? (&NUMBER Number {
	struct pml_print_fmt *fmt;
	uint width;
	POP_INT(width);
	TOP_NODE(fmt);
	fmt->width = width;
})? IdentOrError {
	struct pml_print_fmt *fmt;
	char *fmtstr;
	int fid;

	POP_PTR(fmtstr);
	fid = pml_print_strtofmt(fmtstr);
	if (fid == PML_FMT_UNKNOWN) {
		pml_ast_err(AST, "Unknown print format type '%s'\n",
			    fmtstr);
		pml_peg_error = -1;
	}
	free(fmtstr);
	TOP_NODE(fmt);
	fmt->fmt = fid;
}
MOD / ANY { _ERR("unterminated print modifier"); }


_PrintEnd <- SEMICOLON {
	struct pml_list *list;
	struct pml_print *p;
	TOP_NODE(list);
	p = (struct pml_print *)l_to_node(l_tail(&list->list));
	p->flags |= PML_PFLAG_NEWLINE;
}
/ COMMA SEMICOLON
/ ANY { _ERR("semicolon expected"); }


Statement <- RefAssignment
           / WhileLoop
	   / IfStatement
	   / ControlFlowMod
	   / AssignmentOrExpr
	   / Expr SEMICOLON


StmtOrList <- !LBRACE { PUSH_LIST(); } _Statement
	    / LBRACE  { PUSH_LIST(); } _StatementList RBraceOrError


RefAssignment <- AMP IdentOrError ASSIGN ExprOrError SemiOrError {
	struct pml_locator *loc;
	union pml_expr_u *rhs;
	char *name;

	POP_NODE(rhs);
	POP_PTR(name);
	loc = pmln_alloc(PMLTT_LOCATOR);
	loc->type = PMLTT_LOCADDR;
	loc->name = name;
	PUSH_NODE(pml_assign_alloc(loc, rhs));
}


WhileLoop <- WHILE LPAREN ExprOrError RParenOrError StmtOrList {
	struct pml_list *stmts;
	union pml_expr_u *test;
	POP_NODE(stmts);
	POP_NODE(test);
	PUSH_NODE(pml_while_alloc(test, stmts));
}


IfStatement <- IF LPAREN ExprOrError RParenOrError StmtOrList ElseClause {
	union pml_expr_u *test;
	struct pml_list *tbody;
	struct pml_list *fbody;
	POP_NODE(fbody);
	POP_NODE(tbody);
	POP_NODE(test);
	PUSH_NODE(pml_if_alloc(test, tbody, fbody));
}
ElseClause <- !ELSE { PUSH_NULL_NODE(); } / ELSE StmtOrList


ECFKW <- BREAK / CONTINUE / NEXTRULE / SEND / DROP

ControlFlowMod <- (&(ECFKW SEMICOLON) CtrlFlowSimple / CtrlFlowWithExpr) {
	int type;
	union pml_expr_u *expr;
	POP_NODE(expr);
	POP_INT(type);
	PUSH_NODE(pml_cfmod_alloc(type, expr));
} SemiOrError

CtrlFlowSimple <- BREAK    { PUSH_INT(PML_CFM_BREAK);    PUSH_NULL_NODE(); }
                / CONTINUE { PUSH_INT(PML_CFM_CONTINUE); PUSH_NULL_NODE(); }
                / NEXTRULE { PUSH_INT(PML_CFM_NEXTRULE); PUSH_NULL_NODE(); }
                / SEND     { PUSH_INT(PML_CFM_SENDALL);  PUSH_NULL_NODE(); }
                / DROP     { PUSH_INT(PML_CFM_DROPALL);  PUSH_NULL_NODE(); }

CtrlFlowWithExpr <- RETURN     { PUSH_INT(PML_CFM_RETURN);     } ExprOrError
                  / SEND       { PUSH_INT(PML_CFM_SENDONE);    } ExprOrError
                  / SENDNOFREE { PUSH_INT(PML_CFM_SENDNOFREE); } ExprOrError
                  / DROP       { PUSH_INT(PML_CFM_DROPONE);    } ExprOrError


AssignmentOrExpr <- &LOCSTART Locator _AssignOrExprRest

_AssignOrExprRest <- ASSIGN ExprOrError SemiOrError {
	union pml_expr_u *val;
	struct pml_locator *loc;
	POP_NODE(val);
	POP_NODE(loc);
	PUSH_NODE(pml_assign_alloc(loc, val));
}
/ SEMICOLON


# Expressions

Expr <- OrExpr

OrExpr <- AndExpr (OR AndExpr { return simple_binop(PMLP, PMLOP_OR); })*

AndExpr <- CmpExpr (AND CmpExpr { return simple_binop(PMLP, PMLOP_AND); })*

CmpExpr <- BorExpr (SimpleCmpOp BorExpr { return simple_binop(PMLP, -1); }
                    / MatchOp _MatchPat)?

SimpleCmpOp <- EQ  { PUSH_INT(PMLOP_EQ);  }
             / NEQ { PUSH_INT(PMLOP_NEQ); }
             / LT  { PUSH_INT(PMLOP_LT);  }
             / GT  { PUSH_INT(PMLOP_GT);  }
             / LEQ { PUSH_INT(PMLOP_LEQ); }
             / GEQ { PUSH_INT(PMLOP_GEQ); }


_MatchPat <- _HexPat / _StrPat / _IPv4Pat / _EthPat / _IPv6Pat / _ProtoPat
           / _RegexPat

MatchOp <- MATCH   { PUSH_INT(PMLOP_MATCH);    }
         / NOMATCH { PUSH_INT(PMLOP_NOTMATCH); }


_HexPat <- HEXSTR { PUSH_PTR(hex2str(TEXT)); } SPACING (!DIV {
	return compare_fixed_string(PMLP, 0);
}
/ DIV (HEXSTR { PUSH_PTR(hex2str(TEXT)); }) SPACING {
	return compare_masked_string(PMLP);
})

_StrPat <- QUOTESTR SPACING {
	PUSH_PTR(qstr2str(TEXT, '"'));
	return compare_fixed_string(PMLP, 1);
}

_IPv4Pat <- IPV4ADDR { PUSH_PTR(ipv42str(TEXT)); } SPACING
(!DIV {
	return compare_fixed_string(PMLP, 0);
}
/ DIV (IPV4ADDR { PUSH_PTR(ipv42str(TEXT)); }) SPACING {
	return compare_masked_string(PMLP);
}
/ DIV Number {
	pml_peg_error = num_to_mask(PMLP, 4);
	if (pml_peg_error >= 0)
		return compare_masked_string(PMLP);
})

_IPv6Pat <- IPV6ADDR { PUSH_PTR(ipv62str(AST, TEXT)); } SPACING
(!DIV {
	return compare_fixed_string(PMLP, 0);
}
/ DIV IPV6ADDR { PUSH_PTR(ipv62str(AST, TEXT)); } SPACING {
	return compare_masked_string(PMLP);
}
/ DIV Number {
	pml_peg_error = num_to_mask(PMLP, 16);
	if (pml_peg_error >= 0)
		return compare_masked_string(PMLP);
})


_EthPat <- ETHADDR { PUSH_PTR(eth2str(TEXT)); } SPACING DIV
           (ETHADDR { PUSH_PTR(eth2str(TEXT)); }) SPACING {
	return compare_masked_string(PMLP);
}

_ProtoPat <- LocName {
	struct pml_literal *pat;
	struct pml_locator *loc;
	union pml_expr_u *left;
	int op;

	POP_NODE(loc);
	pat = pml_lookup_ns_literal(AST, loc);
	if (pat == NULL) {
		pml_ast_err(AST, "unable to find protocol value '%s'",
			    loc->name);
		pml_peg_error = -1;
	} else if (pat->type == PMLTT_SCALAR) {
		pml_ast_err(AST,
			    "Protocol field '%s' on right side of match "
			    "operator is neither a byte nor mask string",
			    loc->name);
		pmln_free(pat);
		pml_peg_error = -1;
	} else {
		POP_INT(op);
		POP_NODE(left);
		PUSH_NODE(pml_binop_alloc(op, left, (union pml_expr_u *)pat));
	}
	pmln_free(loc);
}

_RegexPat <- REGEXSTR { PUSH_PTR(qstr2str(TEXT, '`')); } SPACING {
	struct raw *pat;
	struct pml_literal *lit = pmln_alloc(PMLTT_BYTESTR);
	union pml_expr_u *left;
	int op;

	POP_PTR(pat);
	POP_INT(op);
	op = (op == PMLOP_MATCH) ? PMLOP_REXMATCH : PMLOP_NOTREXMATCH;
	pml_bytestr_copyro(AST, &lit->u.bytestr, pat->data, pat->len);
	lit->u.bytestr.len -= 1;
	pml_ast_add_regex(AST, lit);
	POP_NODE(left);
	PUSH_NODE(pml_binop_alloc(op, left, (union pml_expr_u *)lit));
	free(pat);
}


BorExpr <- BXorExpr (BOR BXorExpr { return simple_binop(PMLP, PMLOP_BOR); })*

BXorExpr <- BAndExpr (BXOR BAndExpr { return simple_binop(PMLP, PMLOP_BXOR); })*

BAndExpr <- AddExpr (AMP AddExpr { return simple_binop(PMLP, PMLOP_BAND); })*

AddExpr <- MulExpr (AddOp MulExpr { return simple_binop(PMLP, -1); })*
AddOp <- PLUS { PUSH_INT(PMLOP_PLUS); } / MINUS { PUSH_INT(PMLOP_MINUS); }

MulExpr <- ShiftExpr (MulOp ShiftExpr { return simple_binop(PMLP, -1); })*
MulOp <- TIMES { PUSH_INT(PMLOP_TIMES); }
       / DIV { PUSH_INT(PMLOP_DIV); }
       / MOD { PUSH_INT(PMLOP_MOD); }


ShiftExpr <- UnopExpr (ShiftOp UnopExpr { return simple_binop(PMLP, -1); })*
ShiftOp <- SHL { PUSH_INT(PMLOP_SHL); }
         / SHR { PUSH_INT(PMLOP_SHR); }

UnopExpr <- NOT ParenExpr { return push_unop(PMLP, PMLOP_NOT); }
          / BINV ParenExpr { return push_unop(PMLP, PMLOP_BINV); }
          / MINUS ParenExpr { return push_unop(PMLP, PMLOP_NEG); }
	  / ParenExpr

ParenExpr <- LPAREN Expr RParenOrError / Value

Value <-
  HEXSTR { PUSH_NODE(_alloc_str(AST, hex2str(TEXT), 0)); } SPACING
/ QUOTESTR { PUSH_NODE(_alloc_str(AST, qstr2str(TEXT, '"'), 1)); } SPACING
/ REGEXSTR { PUSH_NODE(_alloc_str(AST, qstr2str(TEXT, '`'), 1)); } SPACING
/ IPV4ADDR { PUSH_NODE(_alloc_str(AST, ipv42str(TEXT), 0)); } SPACING
/ ETHADDR { PUSH_NODE(_alloc_str(AST, eth2str(TEXT), 0)); } SPACING
/ IPV6ADDR { PUSH_NODE(_alloc_str(AST, ipv62str(AST, TEXT), 0)); } SPACING
/ NUMBER { PUSH_NODE(_alloc_num(text2num(TEXT))); } SPACING
/ AT (DottedName / Ident) {
	char *name;
	POP_PTR(name);
	PUSH_NODE(atloc2value(PMLP, name));
} SPACING
/ &LOCSTART Locator
/ Call


LocName <- (DottedName / Ident) {
	struct pml_locator *loc = pmln_alloc(PMLTT_LOCATOR);
	POP_PTR(loc->name);
	if (strchr(loc->name, '.'))
		loc->reftype = PML_REF_UNKNOWN_NS_ELEM;
	PUSH_NODE(loc);
}

Locator <- (LocName / PacketLocator) _SubRegion_?

PacketLocator <- DOLLAR_LP ExprOrError _PacketLocatorRest {
	struct pml_locator *loc;
	POP_NODE(loc);
	POP_NODE(loc->pkt);
	loc->reftype = PML_REF_UNKNOWN_NS_ELEM;
	PUSH_NODE(loc);
}
_PacketLocatorRest <- COMMA ExprOrError RParenOrError LocNameOrError {
	struct pml_locator *loc;
	POP_NODE(loc);
	POP_NODE(loc->idx);
	PUSH_NODE(loc);
}
/ RParenOrError LocNameOrError


Call <- Ident ArgList_ {
	struct pml_list *args;
	char *name;
	POP_NODE(args);
	POP_PTR(name);
	PUSH_NODE(_alloc_call(AST, name, args));
}


ArgList_ <- LPAREN { PUSH_LIST(); } (!RPAREN _Arg (COMMA _Arg)*)? RParenOrError
_Arg <- ExprOrError {
	struct pml_list *list;
	union pml_expr_u *expr;
	POP_NODE(expr);
	TOP_NODE(list);
	l_enq(&list->list, &expr->base.ln);
}


_SubRegion_ <- LBRACKET ExprOrError _SubRegionRest
_SubRegionRest <- COMMA ExprOrError RBracketOrError {
	struct pml_locator *loc;
	union pml_expr_u *len;
	union pml_expr_u *off;
	POP_NODE(len);
	POP_NODE(off);
	POP_NODE(loc);
	loc->len = len;
	loc->off = off;
	PUSH_NODE(loc);
}
/ RBracketOrError {
	struct pml_locator *loc;
	union pml_expr_u *off;
	POP_NODE(off);
	POP_NODE(loc);
	loc->off = off;
	PUSH_NODE(loc);
}

DottedName <- (IDCHARS ('.' IDCHARS)+) { PUSH_PTR(_r2str(TEXT)); } SPACING

Number <- NUMBER { PUSH_INT(text2num(TEXT)); } SPACING

Ident <- !KEYWORD IDCHARS { PUSH_PTR(_r2str(TEXT)); } SPACING

Filename <- FNCHARS { PUSH_PTR(_r2str(TEXT)); }


# Termination Tests

ExprOrError     <- Expr
	         / ANY { _ERR("expression expected"); }

ValueOrError    <- Value
	         / ANY { _ERR("value expected"); }

LocNameOrError  <- LocName
		 / ANY { _ERR("locator expected"); }

IdentOrError    <- Ident
	         / ANY { _ERR("identifier expected"); }

SemiOrError     <- SEMICOLON
	         / ANY { _ERR("semicolon expected"); }

RParenOrError   <- RPAREN
	         / ANY { _ERR("unmatched parentheses"); }

RBraceOrError   <- RBRACE
	         / ANY { _ERR("unmatched braces"); }

RBracketOrError <- RBRACKET
	         / ANY { _ERR("unmatched brackets"); }


# Tokens

IDSTRING <- IDCHARS
IDCHARS  <- [_a-zA-Z] [_a-zA-Z0-9]*
FNCHARS  <- [-a-zA-Z._/\0-9]+

LOCSTART <- IDSTRING SPACING !LPAREN / IDCHARS ('.' IDCHARS)+ / DOLLAR_LP

## Literal Strings
HEXSTR     <- '\\x' HEXPAIR+
QUOTESTR   <- ["] (!["]CHAR)* ["]
REGEXSTR   <- [`] (![`]CHAR)* [`]
CHAR       <- '\\' [0abtnvfr\\"`] /
              '\\' EOL /
              '\\' [0-2] [0-7] [0-7] /
              '\\' [0-7] [0-7]? /
              '\\x' HEXDIGIT HEXDIGIT /
	      !'\\' .


## Literal numbers and addresses
ETHADDR    <- ETHDIGIT ':' ETHDIGIT ':' ETHDIGIT ':'
              ETHDIGIT ':' ETHDIGIT ':' ETHDIGIT ![:0-9a-fA-F]

ETHDIGIT   <- HEXPAIR / HEXDIGIT

IPV6ADDR   <- '::' IPV6TAIL?
	    / IPV6DIGIT '::' IPV6TAIL?
	    / IPV6DIGIT (':' IPV6DIGIT)+ '::'? IPV6TAIL?

IPV6TAIL <- IPV6DIGIT (':' IPV6DIGIT)*


IPV6DIGIT  <- HEXQUAD / HEXTRIPPLE / HEXPAIR / HEXDIGIT


IPV4ADDR   <- IPV4DIGIT '.' IPV4DIGIT '.' IPV4DIGIT '.' IPV4DIGIT

IPV4DIGIT  <- '25' [0-5] /
              '24' [0-9] /
              '1' [0-9] [0-9] /
              [0-9] [0-9]?

NUMBER     <- "0x" HEXDIGIT+ / "0" OCTDIGIT* / [1-9] DECDIGIT*

HEXQUAD    <- HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT
HEXTRIPPLE <- HEXDIGIT HEXDIGIT HEXDIGIT
HEXPAIR    <- HEXDIGIT HEXDIGIT
HEXDIGIT   <- [a-fA-F0-9]
DECDIGIT   <- [0-9]
OCTDIGIT   <- [0-7]


## Keywords
# TODO: be careful about which ones require space to follow
BEGIN      <- "BEGIN" SPACING
TICK       <- "TICK" SPACING
END        <- "END" SPACING
INT        <- "int" SPACE SPACING
STR        <- "str" SPACE SPACING
VOID       <- "void" SPACE SPACING
INLINE     <- "inline" SPACE SPACING
CONST      <- "const" SPACE SPACING
NOT        <- "not" SPACE SPACING
AND        <- "and" SPACE SPACING
OR         <- "or" SPACE SPACING
WHILE      <- "while" SPACING
IF         <- "if" SPACING
ELSE       <- "else" SPACING
RETURN     <- "return" SPACING
BREAK      <- "break" SPACING
CONTINUE   <- "continue" SPACING
NEXTRULE   <- "nextrule" SPACING
SEND       <- "send" SPACING
SENDNOFREE <- "send_no_free" SPACING
DROP       <- "drop" SPACING
PRINT      <- "print" SPACING
IMPORT     <- "import" SPACING

KEYWORD <- ( "BEGIN" / "TICK" / "END" / "int" / "str" / "void" / "const" / "not"
           / "and" / "or" / "while" / "if" / "else" / "return" / "break"
	   / "continue" / "nextrule" / "send" / "send_no_free" / "drop"
	   / "print" / "import") !(IDCHARS / EOF)

## Operator Symbols

### Two-character: put these first in alternate lists
PPBEGIN    <- "?-" SPACING
PPEND      <- "-?" SPACING
EQ         <- "==" SPACING
NEQ        <- "!=" SPACING
MATCH      <- "=~" SPACING
NOMATCH    <- "!~" SPACING
LEQ        <- "<=" SPACING
SHL        <- "<<" SPACING
GEQ        <- ">=" SPACING
SHR        <- ">>" SPACING
DOLLAR_LP  <- "$(" SPACING

### One-character
SEMICOLON  <- ";" SPACING
PLUS       <- "+" SPACING
MINUS      <- "-" ![?] SPACING
TIMES      <- "*" SPACING
DIV        <- "/" SPACING
MOD        <- "%" SPACING
AMP        <- "&" SPACING
BOR        <- "|" SPACING
BXOR       <- "^" SPACING
BINV       <- "~" SPACING
LBRACE     <- "{" SPACING
RBRACE     <- "}" SPACING
LPAREN     <- "(" SPACING
RPAREN     <- ")" SPACING
LBRACKET   <- "[" SPACING
RBRACKET   <- "]" SPACING
COMMA      <- "," SPACING
AT         <- "@" SPACING
ASSIGN     <- "=" ![=~] SPACING
LT         <- "<" SPACING
GT         <- ">" SPACING

# Basic definitions for comments, spaces and end-of-line
SPACING <- (SPACE / COMMENT)*
COMMENT <- '#' (!EOL .)* (EOL / EOF)
SPACE   <- [ \t\r\n]
EOL     <- '\r\n' / '\n' / '\r'
EOF     <- !.
ANY	<- &. / !.


%%


static char *_r2str(struct raw *r)
{
	char *s = emalloc(r->len + 1);
	memmove(s, r->data, r->len);
	s[r->len] = '\0';
	return s;
}


static struct raw *_ralloc(size_t len)
{
	struct raw *r;
	if (SIZE_MAX - sizeof(struct raw) < len)
		err("Size overflow allocating string\n");
	r = emalloc(sizeof(struct raw) + len);
	r->data = (byte_t *)(r + 1);
	r->len = len;
	return r;
}


static struct raw *hex2str(struct raw *s)
{
	struct raw *r;
	size_t len;
	uchar *sp = s->data + 2;
	uchar *dp;

	abort_unless(s->len >= 4 && s->len % 2 == 0);

	len = (s->len - 2) / 2;
	r = _ralloc(len);
	dp = r->data;
	while (len-- > 0) {
		*dp++ = hexpairval(sp);
		sp += 2;
	}
	return r;
}


static uint hexpairval(char *s)
{
	return (chnval(s[0]) << 4) | chnval(s[1]);
}


static int isodigit(int x) { return x >= '0' && x <= '7'; }

static struct raw *qstr2str(struct raw *s, int qchar)
{
	struct raw *r = _ralloc(s->len);
	uchar *dp = r->data;
	uchar v;
	ulong i;
	
	abort_unless(s->len >= 2 && s->data[0] == qchar);

	/* stop at terminating quote */
	for (i = 1; i < s->len && s->data[i] != qchar; ++i) {
		if (s->data[i] != '\\') {
			*dp++ = s->data[i];
		} else {
			abort_unless(i < s->len - 1);
			switch(s->data[i+1]) {
			case '\\': *dp++ = '\\'; break;
			case '0':  *dp++ = '\0'; break;
			case 'a':  *dp++ = '\a'; break;
			case 'b':  *dp++ = '\b'; break;
			case 't':  *dp++ = '\t'; break;
			case 'n':  *dp++ = '\n'; break;
			case 'v':  *dp++ = '\v'; break;
			case 'f':  *dp++ = '\f'; break;
			case 'r':  *dp++ = '\r'; break;
			case '"':  *dp++ = '"' ; break;
			case '`':  *dp++ = '`' ; break;
			case 'x':
				abort_unless(i + 4 < s->len);
				abort_unless(isxdigit(r->data[i+2]));
				abort_unless(isxdigit(r->data[i+3]));
				*dp++ = hexpairval(&r->data[i+2]);
				i += 2;
				break;
			default:
				abort_unless(i < s->len - 1);
				abort_unless(isodigit(r->data[i+1]));
				v = chnval(r->data[i+1]);
				if (isodigit(r->data[i+2])) {
					abort_unless(i < s->len - 2);
					v = (v << 3) |
					    chnval(r->data[i+2]);
					i += 1;
				}
				if (isodigit(r->data[i+2])) {
					abort_unless(i < s->len - 2);
					v = (v << 3) |
					    chnval(r->data[i+2]);
					i += 1;
				}
				*dp++ = v;
			}
			i += 1;	/* increment at least one extra */
		}
	}
	
	r->len = dp - r->data + 1;
	*dp = '\0';
	return r;
}


static struct raw *ipv62str(struct pml_ast *ast, struct raw *s)
{
	struct raw *st = _ralloc(s->len + 1);
	struct raw *r = _ralloc(16);
	memmove(st->data, s->data, s->len);
	st->data[s->len] = '\0';
	st->len = s->len;
	if (str_parse_ip6a(r->data, st->data) < 0) {
		pml_ast_err(ast, "Invalid IPv6 address: '%s'", st->data);
		free(r);
		r = NULL;
	}
	free(st);
	return r;
}


static struct raw *ipv42str(struct raw *s)
{
	struct raw *r = _ralloc(4);
	uint a[4];
	int i;

	sscanf(s->data, "%u.%u.%u.%u", &a[0], &a[1], &a[2], &a[3]);
	for (i = 0; i < 4; ++i)
		r->data[i] = a[i];
	return r;
}


static struct raw *eth2str(struct raw *s)
{
	struct raw *r = _ralloc(6);
	uint a[6];
	int i;
	
	sscanf(s->data, "%x:%x:%x:%x:%x:%x", &a[0], &a[1], &a[2], &a[3], &a[4],
	       &a[5]);
	for (i = 0; i < 6; ++i)
		r->data[i] = a[i];
	return r;
}


static struct pml_literal *atloc2value(struct pml_parser *pmlp, char *name)
{
	struct pml_literal *v = NULL;
	struct ns_elem *ne = ns_lookup(NULL, name);

	if (ne == NULL) {
		pml_ast_err(pmlp->ast, "invalid @location: '%s'\n", name);
	} else if (ne->type == NST_NAMESPACE) {
		struct ns_namespace *ns = (struct ns_namespace *)ne;
		v = pmln_alloc(PMLTT_SCALAR);
		v->width = 4;
		v->u.scalar = ns->prid;
	} else if (ne->type != NST_PKTFLD) {
		struct ns_pktfld *pf = (struct ns_pktfld *)ne;
		v = pmln_alloc(PMLTT_SCALAR);
		v->width = 4;
		v->u.scalar = pf->prid;
	} else {
		pml_ast_err(pmlp->ast, "@location '%s' is neither a namespace "
				       "or a packet field\n", name);
	}
	free(name);

	return v;
}

static struct pml_literal *_alloc_str(struct pml_ast *ast, struct raw *val,
				      int nxchars)
		
{
	struct pml_literal *lit;
	if (val == NULL)
		return NULL;
	lit = pmln_alloc(PMLTT_BYTESTR);
	pml_bytestr_copyro(ast, &lit->u.bytestr, val->data, val->len);
	lit->u.bytestr.len -= nxchars;
	free(val);
	return lit;
}


static ulong text2num(struct raw *r)
{
	char *s = _r2str(r);
	ulong x = strtoul(r->data, NULL, 0);
	free(s);
	return x;
}

static struct pml_literal *_alloc_num(unsigned long val)
{
	struct pml_literal *lit = pmln_alloc(PMLTT_SCALAR);
	lit->width = 4;
	lit->u.scalar = val;
	return lit;
}


static struct pml_call *_alloc_call(struct pml_ast *ast, char *name,
				    struct pml_list *args)
{
	struct pml_call *c = NULL;
	struct pml_function *f = pml_ast_lookup_func(ast, name);
	uint alen = l_length(&args->list);

	if (f == NULL) {
		pml_ast_err(ast, "Undefined function: %s\n", name);
	} else if (f->arity != alen) {
		pml_ast_err(ast, "argument length for call of '%s' does"
				 "not match function arity (%u vs %u)\n",
			    f->name, alen, f->arity);
	} else {
		c = pml_call_alloc(f, args);
	}

	free(name);
	if (c == NULL)
		pmln_free(args);
	return c;
}


static int push_func_hdr(struct pml_parser *pml_peg_ctx)
{
	int pml_peg_error = 0;
	struct list *t, *x;
	struct pml_variable *param;
	struct pml_list *params;
	struct pml_function *f = pmln_alloc(PMLTT_FUNCTION);

	POP_NODE(params);
	POP_PTR(f->name);
	POP_INT(f->rtype);

	l_for_each_safe(t, x, &params->list) {
		f->arity += 1;
		param = container(t, struct pml_variable, ln);
		l_rem(&param->ln);
		if (pml_func_add_param(f, param) < 0) {
			pml_ast_err(AST, "Error adding parameter '%s' "
					 "to function '%s'\n",
				    f->name, param->name);
			pmln_free(param);
			pmln_free(f);
			pml_peg_error = -1;
			goto out;
		}
	}

	AST->livefunc = f;
	AST->ltab = &f->vars;
	PUSH_NODE(f);

out:
	pmln_free(params);
	return pml_peg_error;
}


static int add_func_proto_or_decl(struct pml_parser *pml_peg_ctx)
{
	int pml_peg_error = 0;
	struct pml_function *f, *f0;
	struct pml_list *body;

	POP_NODE(body);
	POP_NODE(f);

	f0 = pml_ast_lookup_func(AST, f->name);
	if (f0 != NULL) {
		if (body != NULL &&
		    (f0->body != NULL || PML_FUNC_IS_INTRINSIC(f0))) {
			pml_ast_err(AST,
				    "duplicate function declaration '%s'",
				    f->name);
			pml_peg_error = -1;
			pmln_free(body);
			goto out;
		}
		if (pml_check_func_proto(AST, f0, f) < 0) {
			pml_peg_error = -1;
			pmln_free(body);
			goto out;
		}
		pmln_free(f);
		f = f0;
	}

	if (body != NULL) {
		f->body = (union pml_node *)body;
		pml_peg_error = pml_ast_add_func(AST, f);
	} else {
		pml_peg_error = pml_ast_add_func_proto(AST, f);
	}

out:
	if (pml_peg_error < 0)
		pmln_free(f);
	AST->livefunc = NULL;
	AST->ltab = NULL;

	return pml_peg_error;
}


static int compare_fixed_string(struct pml_parser *pml_peg_ctx, int nxchars)
{
	struct raw *val;
	int op;
	union pml_expr_u *left;
        struct pml_literal *right = pmln_alloc(PMLTT_BYTESTR);

	POP_PTR(val);
	POP_INT(op);
	POP_NODE(left);
        pml_bytestr_copyro(AST, &right->u.bytestr, val->data, val->len);
	right->u.bytestr.len -= nxchars;
	PUSH_NODE(pml_binop_alloc(op, left, (union pml_expr_u *)right));
	free(val);
	return 0;
}


static int compare_masked_string(struct pml_parser *pml_peg_ctx)
{
	struct raw *mask;
	struct raw *val;
	int op;
	union pml_expr_u *left;
        struct pml_literal *right = pmln_alloc(PMLTT_MASKVAL);

	POP_PTR(mask);
	POP_PTR(val);
	POP_INT(op);
	POP_NODE(left);

	pml_maskval_copyro(AST, &right->u.maskval, val->data, val->len,
			   mask->data, mask->len);
	PUSH_NODE(pml_binop_alloc(op, left, (union pml_expr_u *)right));
	free(val);
	free(mask);
	return 0;
}


static int num_to_mask(struct pml_parser *pml_peg_ctx, int nbytes)
{
	struct raw *mask;
	uint i, nbits;
	
	POP_INT(nbits);
	if (nbytes == 4 && nbits > 32) {
		pml_ast_err(AST, "IPv4 address mask > 32 bits\n");
		return -1;
	} else if (nbits > 128) {
		abort_unless(nbytes == 16);
		pml_ast_err(AST, "IPv6 address mask > 128 bits.\n");
		return -1;
	}
	

	mask = _ralloc(nbytes);
	memset(mask->data, 0, mask->len);
	i = 0;
	while (nbits > 8) {
		mask->data[i++] = 0xff;
		nbits -= 8;
	}
	mask->data[i] = 0xFF - ((1 << (8 - nbits)) - 1);
	PUSH_PTR(mask);

	return 0;
}


static int simple_binop(struct pml_parser *pml_peg_ctx, int op)
{
	union pml_expr_u *e1, *e2;
	POP_NODE(e2);
	if (op < 0)
		POP_INT(op);
	POP_NODE(e1);
	PUSH_NODE(pml_binop_alloc(op, e1, e2));
	return 0;
}


static int push_unop(struct pml_parser *pml_peg_ctx, int op)
{
	union pml_expr_u *e;
	POP_NODE(e);
	PUSH_NODE(pml_unop_alloc(op, e));
	return 0;
}


static void _err(struct pml_parser *pmlp, const char *s)
{
	str_copy(pmlp->errbuf, s, sizeof(pmlp->errbuf));
	pmlp->echar = pmlp->pegp->pstate.cur.i;
}


static struct pml_stack_entry *_push(struct pml_parser *pmlp, int type,
				     const char *line, uint file)
{
	if (pmlp->sp >= MAXSTACK) {
		pml_ast_err(pmlp->ast, "stack overflow at %s:%d",
			    file, line);
		return NULL;
	}
	pmlp->stack[pmlp->sp].pse_type = type;
	return &pmlp->stack[pmlp->sp++];
}


static struct pml_stack_entry *_pop(struct pml_parser *pmlp, int type,
				    const char *file, uint line)
{
	struct pml_stack_entry *pse;
	if (pmlp->sp <= 0 || pmlp->sp > MAXSTACK) {
		pml_ast_err(pmlp->ast, "stack underflow at %s:%d",
			    file, line);
		return NULL;
	}
	pse = &pmlp->stack[pmlp->sp - 1];
	if (type != PSE_TYPE_INVALID && pse->pse_type != type) {
		pml_ast_err(pmlp->ast,
			    "unexpected type %d at %s:%d -- %d expected",
			    pse->pse_type, file, line, type);
		return NULL;
	}
	pse->pse_type = PSE_TYPE_INVALID;
	--pmlp->sp;
	return pse;
}


static struct pml_stack_entry *_top(struct pml_parser *pmlp, int type,
				    const char *file, uint line)
{
	struct pml_stack_entry *pse;
	if (pmlp->sp <= 0 || pmlp->sp > MAXSTACK) {
		pml_ast_err(pmlp->ast, "stack underflow at %s:%d",
			    file, line);
		return NULL;
	}
	pse = &pmlp->stack[pmlp->sp - 1];
	if (type != PSE_TYPE_INVALID && pse->pse_type != type) {
		pml_ast_err(pmlp->ast,
			    "unexpected type %d at %s:%d -- %d expected",
			    pse->pse_type, file, line, type);
		return NULL;
	}
	return pse;
}


struct pml_parser *pmlp_alloc(void)
{
	struct pml_parser *pmlp;

	pmlp = calloc(sizeof(*pmlp), 1);
	if (pmlp == NULL)
		return NULL;

	pmlp->pegp = calloc(sizeof(*pmlp->pegp), 1);
	if (pmlp == NULL) {
		free(pmlp);
		return NULL;
	}
	pml_peg_init(pmlp->pegp, &nextc);
	l_init(&pmlp->inputs.ln);
	pmlp->last_input = NULL;
	l_init(&pmlp->chmap);
	pmlp->inputs.type = NTYPE;
	pmlp->inputs.lineno = 0;
	str_copy(pmlp->inputs.name, "*END OF INPUT*",
		 sizeof(pmlp->inputs.name));
	pmlp->inputs.inp = &null_inport;
	pmlp->echar = 0;
	str_copy(pmlp->errbuf, "", sizeof(pmlp->errbuf));

	return pmlp;
}


void pmlp_ipath_reset(struct pml_parser *pmlp)
{
	memset(pmlp->ipath, 0, sizeof(pmlp->ipath));	/* paranoia */
	str_copy(pmlp->ipath, DEFAULT_PATH, sizeof(pmlp->ipath));
}


int pmlp_ipath_append(struct pml_parser *pmlp, const char *dir)
{
	size_t n;
	n = str_cat(pmlp->ipath, ":", sizeof(pmlp->ipath));
	if (n >= sizeof(pmlp->ipath)) {
		pmlp_ipath_reset(pmlp);
		return -1;
	}
	n = str_cat(pmlp->ipath, dir, sizeof(pmlp->ipath));
	if (n >= sizeof(pmlp->ipath)) {
		pmlp_ipath_reset(pmlp);
		return -1;
	}
	return 0;
}


int pmlp_add_instring(struct pml_parser *pmlp, const char *s, int front,
		      const char *name)
{
	struct inputs *pi;

	abort_unless(pmlp && s);
	pi = emalloc(sizeof(*pi));
	pi->type = STYPE;
	str_copy(pi->name, name, sizeof(pi->name));
	pi->lineno = 1;
	csinp_init(&pi->inp_u.csi, s);
	pi->inp = &pi->inp_u.csi.in;
	if (front)
		l_push(INLIST(pmlp), &pi->ln);
	else
		l_enq(INLIST(pmlp), &pi->ln);

	return 0;
}


int pmlp_add_infile(struct pml_parser *pmlp, FILE *f, int front, const char *fn)
{
	struct inputs *pi;

	abort_unless(pmlp && f);
	pi = emalloc(sizeof(*pi));
	pi->type = FTYPE;
	str_copy(pi->name, fn, sizeof(pi->name));
	pi->lineno = 1;
	finp_init(&pi->inp_u.fi, f);
	pi->inp = &pi->inp_u.fi.in;
	if (front)
		l_push(INLIST(pmlp), &pi->ln);
	else
		l_enq(INLIST(pmlp), &pi->ln);

	return 0;
}


int pmlp_open_add_infile(struct pml_parser *pmlp, const char *fn, int front)
{
	FILE *fp;
	char pbuf[512];
	char *path;
	int esave;
	struct path_walker pw;

	pwalk_init(&pw, pmlp->ipath, ":", '/');
	while ((path = pwalk_next(&pw, fn, pbuf, sizeof(pbuf))) != NULL) {
		fp = fopen(path, "r");
		if (fp != NULL)
			break;
	}

	if (fp == NULL) {
		errno = ENOENT;
		return -1;
	}

	if (pmlp_add_infile(pmlp, fp, 1, path) < 0) {
		esave = errno;
		fclose(fp);
		errno = esave;
		return -1;
	}

	return 0;
}


static void popinput(struct pml_parser *pmlp)
{
	struct inputs *pi = CURINPUT(pmlp);
	l_rem(&pi->ln);
	inp_close(pi->inp);
	free(pi);
}


void pmlp_set_eoicb(struct pml_parser *pmlp, pmlp_eoi_f eoicb)
{
	pmlp->eoicb = eoicb;
}


static void add_iregion(struct pml_parser *pmlp, struct inputs *pi)
{
	struct iregion *ir = ecalloc(sizeof(*ir), 1);
	str_copy(ir->name, pi->name, sizeof(ir->name));
	ir->nchars = 0;
	l_enq(&pmlp->chmap, &ir->ln);
	pmlp->last_input = pi;
}


static void add_iregion_char(struct pml_parser *pmlp)
{
	struct iregion *ir;
	abort_unless(!l_isempty(&pmlp->chmap));
	ir = l_to_iregion(l_tail(&pmlp->chmap));
	++ir->nchars;
}


static int nextc(void *pmlpp)
{
	struct pml_parser *pmlp = pmlpp;
	int c;
	struct inputs *pi;

restart:
	pi = CURINPUT(pmlp);
	c = inp_getc(pi->inp);
	if (c >= 0) {
		if (c == '\0')
			fprintf(stderr, "BAZ\n");
		if (pi != pmlp->last_input)
			add_iregion(pmlp, pi);
		add_iregion_char(pmlp);
		if (c == '\n')
			pi->lineno++;
		return c;
	}

	/* TODO: handle input error */
	if (NOINPUT(pmlp, pi)) {
		if (pmlp->eoicb != NULL)
			(*pmlp->eoicb)(pmlp);
		pi = CURINPUT(pmlp);
		if (NOINPUT(pmlp, pi))
			return NEXTCEOF;
	} else {
		popinput(pmlp);
	}
	goto restart;

	/* treat a new file/string like a whitespace w.r.t separation */
	return ' ';
}


static void pmlp_reset(struct pml_parser *pmlp)
{
	struct pml_stack_entry *pse;

	pml_peg_reset(pmlp->pegp);

	while (!NOINPUT(pmlp, CURINPUT(pmlp)))
		popinput(pmlp);

	while (pmlp->sp > 0) {
		pse = &pmlp->stack[--pmlp->sp];
		if (pse->pse_type == PSE_TYPE_NODE)
			pmln_free(pse->pse_ptr);
		else if (pse->pse_type == PSE_TYPE_PTR)
			free(pse->pse_ptr);
		memset(pse, 0, sizeof(*pse));
		pse->pse_type = PSE_TYPE_INVALID;
	}

	while (!l_isempty(&pmlp->chmap))
		free(l_pop(&pmlp->chmap));

	pmlp->echar = 0;
	pmlp->ast = NULL;
	pmlp->last_input = NULL;
}


static void set_parse_error(struct pml_parser *pmlp)
{
	struct cpg_state *cpg = &pmlp->pegp->pstate;
	ulong ech = cpg->cur.i - 1;
	struct iregion *ir;
	ulong icc = 0;
	ulong i;
	ulong line;
	ulong lch;
	char tstr[256];

	ech = pmlp->echar ? pmlp->echar : cpg->cur.i - 1;

	if (l_isempty(&pmlp->chmap)) {
		str_copy(pmlp->errbuf, "No input specified",
			 sizeof(pmlp->errbuf));
		return;
	}

	ir = l_to_iregion(l_head(&pmlp->chmap));
	while (ech - icc > ir->nchars) {
		struct list *next = l_next(&ir->ln);
		abort_unless(next != l_end(&pmlp->chmap));
		icc += ir->nchars;
		ir = l_to_iregion(next);
	}

	for (i = 0, lch = 1, line = 1; icc + i < ech; ++i, ++lch) {
		if (cpg->buf[1 + i + icc] == '\n') {
			++line;
			lch = 1;
		}
	}

	if (pmlp->ast->error)
		str_copy(tstr, pmlp->ast->errbuf, sizeof(tstr));
	else if (pmlp->echar != 0)
		str_copy(tstr, pmlp->errbuf, sizeof(tstr));
	else
		str_copy(tstr, "syntax error", sizeof(tstr));

	snprintf(pmlp->errbuf, sizeof(pmlp->errbuf),
		 "Error on line %lu character %lu: %s", line, lch, tstr);
}


int pmlp_parse(struct pml_parser *pmlp, struct pml_ast *ast)
{
	int rv;

	abort_unless(ast != NULL);
	str_copy(pmlp->errbuf, "", sizeof(pmlp->errbuf));
	pmlp->ast = ast;
	rv = pml_peg_parse(pmlp->pegp, pmlp, pmlp);
	if (rv < 0)
		set_parse_error(pmlp);
	abort_unless(rv < 0 || pmlp->sp == 0);
	pmlp_reset(pmlp);
	return rv;
}


void pmlp_free(struct pml_parser *pmlp)
{
	if (pmlp == NULL)
		return;
	pml_peg_fini(pmlp->pegp);
	pmlp_reset(pmlp);
	free(pmlp->pegp);
	free(pmlp);
}


void pmlp_set_debug(struct pml_parser *pmlp, int on)
{
	pmlp->pegp->pstate.debug = on;

}


const char *pmlp_get_error(struct pml_parser *pmlp)
{
	return pmlp->errbuf;
}
