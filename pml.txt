PML INTRODUCTION
----------------

PML is a simple scripting language intended to be similar to 'awk' for packet
streams instead of text records.  PML stands for Packet Manipulation
Language.  The PML implementation in this distribution compiles to the
NetVM virtual machine.  Like AWK, PML programs consist of three
sections, the 'BEGIN segment' that executes at program start, the
'packet segment' that executes on once on every packet and the 'END
segment' that executes after the program receives notification that no
further packets will arrive.  Unlike AWK, PML programs can also contain a 'TICK
segment' that executes once per millisecond to handle simple timing events.

The packet segment consists of a series of rules each with a pattern and
an action.  Each packet gets compared against the rules sequentially.
If the packet matches the pattern then the program executes the rule
action.  A rule action can execute multiple statements.  These
statements can include operations to create and delete packets.  They
can also halt processing on the current packet to circumvent the
remaining rules.

PML supports an extensible namespace for packet protocols.  When a
programmer generates the definitions for parsing a protocol, defining
its fields and its constants through the ONICS protoparse framework, the
PML parser automatically picks up those definitions and allows the PML
programmer to access them.  The upshot of all of this for PML is that the 
actual "vocabulary" of a PML program depends on the protocol definitions 
that the PML compiler/interpreter loads.  This makes the language readily
extensible to new protocols.  The NetVM can support and future work will
include making the protocol namespaces and fields discoverable and
allowing access to packet fields based on protocol identifiers and
indices, rather than field names.  The current ONICS toolkit includes
protocol definitions for Ethernet II, IP, IPv6, ICMP, ICMPv6, UDP and
TCP protocols.

PML has six basic data types: signed 64-bit integers (int), byte 
strings (str), byte string references (sref), masked byte strings, 
regular expressions and the void type.  However, PML can only store
a subset of these types in variables.  A PML global variable can hold a
int, str or sref.  A PML local variable or parameter can only hold an
int or sref.  Masked byte strings and regular expressions are only 
available as literal constants (currently).  The void type can only 
be a return type for a function.

PML also supports named constants.  A program can not modify a constant 
value and said value may not have any associated memory space in the 
final program.  These values are used like #defines in the C language.  
A program can define these symbols as PML expressions as long as the 
expression itself is constant and the compiler can determine its final
value at compile time.  Thus a program can define a constant in terms of
operations on other constants.

PML has three types of subroutines all of which take a fixed number of
parameters.  A function subroutine can return a scalar, reference or a 
void value (meaning no return type).  A function executes a list of
statements and can be recursive or mutually recursive with another function.

An 'inline' contains only a single scalar expression and can not be
recursive.  PML inlines are safe macros without side effects.  The
compiler can even use constant propagation to determine an inline 
result at compile time provided every parameter to the inline is
constant.  Inlines can invoke other inlines but, again, can not recurse 
directly or indirectly.  An inline can invoke a function that invokes 
the inline.  But this will not result in an inline expansion past the
function call so the inline itself is not recursive.  The function in
that case, however, is.

An 'intrinsic' is a subroutine whose definition is outside of the PML
language.  This provides function-style syntax for operations that the
PML program simply can not perform, but needs access to.  The PML
language defines intrinsics for accessing packet metadata, manipulating
packet buffers, manipulating packet parses, premature program exit and
accelerated bit operations.  An intrinsic returns an int or void but in
it is possible for one to return any data type including those not
usually available to functions.


PROGRAM SYNTAX
--------------

At the highest level, a PML program consists of a set of declarations.
Each declaration can declare:
  * a rule
  * a function prototype (needed for recursion)
  * a function definition
  * an inline
  * a constant
  * a global variable 


COMMENTS
--------

Comments in PML start with a '#' that isn't in a string constant and
they continue until the end of the line.


RULES
-----

A rule definition take the form:

  RULE ::= PATTERN '{' [LOCAL_VAR_DECL]* [STATEMENT_LIST]* '}'

A PATTERN must be one of 'BEGIN', 'TICK', 'END' or a PML expression 
enclosed by '?-' and '-?'.  The order of rule declaration matters because
the PML program executes rules in their declaration order.  There can be 
multiple rules with the 'BEGIN', 'TICK' and 'END' pattern.  PML executes 
rules with the 'BEGIN' pattern at startup before any packets are read in
the system.  PML executes the 'TICK' segment, if present, once every
millisecond.  It exectues rules with the 'END' pattern after it determines
that there are no further packets to process.  Note that the exit()
intrinsic will abort execution immediately and the program will not
execute rules in the 'END' pattern that it has not already executed.
If the program contains a 'TICK' segment, but no packet rules, then the
program runs until the 'TICK' segment invokes the exit() intrinsic.

PML evaluates a rule with an expression pattern once for every packet
that it receives.  The PML program evaluates the PATTERN exression (the
'rule pattern').  If the expression returns non-zero scalar result then
the program executes the STATEMENT_LIST (the 'rule action').  It is also 
worth noting that PML can coerce any type to an integer value (see below)
so any PML expression is valid in a rule pattern.  Again, PML evaluates
the rules in order and a rule's actions (in the STATEMENT_LIST) can cause
the program to skip later rules.  So order of declaration is important.  
A PML program can omit the pattern expression which will cause the rule
action to fire on every packet.

The LOCAL_VAR_DECL is an optional series of local variable declarations.
These are discussed in the next section.

If PML comes to the end of the packet rules without any other statement
that aborts control on the current packet (see STATEMENTS), then
PML will transmit all packets remaining in the working set.  (see PACKET
WORKING SET)


TYPES
-----

PML supports the following native types:
 - void			-> no type or value
 - int			-> signed 64-bit integer
 - str			-> byte string
 - sref			-> reference to a byte string
 - mstr			-> byte string with equal length byte string mask
 - regex		-> regular expression

The type void may only be used for a function return value.  The program
is not able to declare variables of type mstr and regex.  Local
variables and function parameters may not have type str:  only global
varaibles can have that type in this version of the language.
   

VARIABLE DECLARATIONS
---------------------

PML allows one to declare four types of variables:  global variables, local
variables, function parameters and constants.  A global variable is the
only variable that can be defined to have a type of 'str'.  It can also
have a type of 'int' or 'sref'.  A global variable declaration takes the form:

  int NAME [= EXPRESSION] ;
  sref NAME ;
  str NAME '[' LENGTH ']' [= EXPRESSION] ;

The first form declares a 64-byte integer variable.  If EXPRESSION is
present, then the variable is initialized to the value of the
expression.  Otherwise it is initialized to 0.  The second form declares
a globally accessible string reference.  It may not be initialized at
compile time.  The third form declares a byte string of LENGTH bytes.
If EXPRESSION is present, then the string is initialized to the value of
the expression (which must be of type 'str').  If the variable has a
longer length than the initialization expression, then the program
initializes the remaining bytes in the string are initialized to 0.  If
the initializer is greater in length than the variable then the compiler
will report an error.  A byte string variable without an initializer
will initially contain all 0s in every byte.


A program can have local variable declarations at the beginning of the
action portions of a rule or the body of a function.  They may not
appear in inlines however.  A rule action or function body may use
variables of type 'int' without declaring them.  Referencing a variable
name in a function body or rule action statement that has no binding to
a previously declared variable or protocol-specific name (see 'LOCATORS'
below) automatically declares a local variable of type 'int'.

PML initializes all uninitialized variables to 0 (int), a string of 0s
(str) or a null reference (sref) depending on the variable type.


EXPRESSIONS
-----------

In the following, let 'E', 'E1', 'E2' ... refer to expressions.  Tokens of 
the form *LOC refers to a 'locator'.  This is an rvalue consisting of a 
variable name or a protocol namespace constant.  

In PML an expression is one of:
  - a positive decimal integer
  - a hexadecimal integer preceeded by '0x'
  - a locator (see below)
  - a function or inline call of the form:
	<funcname> '(' [E1, E2...] ')'
  - a literal byte string:  
	a double quoted string with usual C substitutions
	  OR
  	'\x' followed by an even number of hex digits
	  OR
	a dotted quad IPv4 address (4 byte string)
	  OR
	an IPv6 address (16 byte string)
	  OR
	an 802.1 MAC address (6 byte string)


  (In order of precedence)

  - '(' E ')'   : parenthesized expression
  - '&' E	: string reference to E (value has type 'sref')
  - '-' E       : numerically negated expression
  - 'not' E	: logcal inversion (value is 0 or 1)
  - '~' E	: binary inversion (bit-wise inversion)
  - E1 << E2	: E1 left-shifted by E2
  - E1 >> E2	: E1 right-shifted by E2
  - E1 % E2	: E1 modulo E2
  - E1 / E2	: E1 divided by E2
  - E1 * E2	: E1 multiplied by E2
  - E1 + E2	: E1 plus E2
  - E1 - E2	: E1 minus E2
  - E1 & E2	: E1 binary-ANDed with E2
  - E1 | E2	: E1 binary-ORed with E2
  - E1 ^ E2	: E1 binary-XORed with E2
  - E1 == E2	: E1 equals E2 (numeric compare, value is 0 or 1)
  - E1 != E2	: E1 does not equal E2 (numeric compare, value is 0 or 1)
  - E1 < E2	: E1 less than E2 (numeric compare, value is 0 or 1)
  - E1 > E2	: E1 greater than E2 (numeric compare, value is 0 or 1)
  - E1 <= E2	: E1 less or equal to E2 (numeric compare, value is 0 or 1)
  - E1 >= E2	: E1 greater or equal to E2 (numeric compare, value is 0 or 1)
  - E1 =~ E2	: E1 matches E1
  - E1 !~ E2	: E1 does not match E2
  - E1 'and' E2 : E1 and E2 (boolean comparison, value is 0 or 1)
  - E1 'or ' E2 : E1 or E2 (boolean comparison, value is 0 or 1)


The type of an expression is usually 'int'.  There are four exceptions.
A string reference expression (& E) has type 'sref'.  A byte string
literal has type 'str'.  A function or inline call has a type of the
return value of the function or inline (always 'int' for inlines).
Finally, a locator expression's type is equal to the type value that the
locator refers to.  (see below)

The value of the expression E in a string reference operator must be a
byte string.  ** Currently, 'E' must be a locator and can not any other
type of expression that has type 'str'.  I intend to fix this. **

The match comparison operators (=~ and !~) perform different comparisons
depending on the type of the right hand expression.  The left-hand 
expression must have a type of str or sref.  The right hand expression
must have type str, mstr or regex.  For the rest of this discussion
Let E1 be the left-hand side expression in the match expression and 
let E2 be the right-hand side.

If E2 has type 'str', then PML performs an exact string comparison (the
lengths of the E1 and E2 must be equal in order to be equal).  If the
E2 has type 'mstr' then PML performs a masked string comparison.  A
masked string value has a 'value' component and a 'mask' component both
of which are byte strings.  Both 'value' and 'mask' must have the same
length.  Expression E1 matches an mstr E2 if and only if: 1) the length of
E1 matches the lengths of E2's value and mask and 2) each bit b1 in
E1 matches its corresponding bit b2 in E2.value when the corresponding 
bit 'm' in E2.mask is set.  Finally, if E2 has type regex then PML
performs a regular expression mask of the pattern E2 against E1.

Aside from the match and reference operators, all other operators
require the types of their subexpressions to be 'int'.  Each expression
argument in a function or inline call must have the same type as the 
corresponding formal paramenter in the function declaration.


TYPE CONVERSION
---------------

PML will automatically attempt to convert an expression to the type
required by a given operator or function parameter.  PML will also try
to implicitly convert the expression in a 'return' statement (see below)
to the return type of the enclosing function.  The language performs the
following type conversion implicitly:

  mstr->str - returns the 'value' portion of the masked string

  str->int  - treat up to the first 8 bytes of the string as a big
              endian 2s-compliment arithmetic integer.  If the string
	      is less than 8 bytes, logcially pad to 8 bytes with
	      zeros in the high order bits.

  mstr->int - convert the value and the mask of the masked string
	      to 'int' as above and return the binary AND of the
	      two resulting values.

  str->void - discards the value
  int->void
  sref->void
  mstr->void


LOCATORS
--------
A locator is a named reference to a value.  The name may refer to a
variable, a protocol, a field in a packet or a constant.  A locator can
have the following forms:

DIRECT ACCESS:
  name		-- could refer to: variable, constant, packet field,
		   protocol, or protocol constant

  name.name2[...]
		-- could refer to: packet field, protocol or protocol constant

  @name{p}
  @name{p}.name2...
  @name{p,i}
  @name{p,i}.name2...
		-- could refer to: packet field

SUBSTRING ACCESS: 

(DA is a locator string with a direct access form.  DA must refer to a
value of type 'str' or 'sref'.)

  DA[off]	
  DA[off, len]	
		-- could refer to: variable, protocol, protocol constant 
		   packet field. (The form of the direct access
		   substring restricts possible types for this locator.)

PROTOCOL ID:
  @@name
  @@name.name2	-- could refer to: protocol name



At a given point in the PML program, the compiler consults the following
namespaces in the following order to determine which value a locator
refers to: protocol namespace, parameters, constants global variables, local
variables.  Recall from VARIABLES above, that a locator matches none of
the above namespaces will implicitly cause a local variable declaration
if the reference is in the body of a function or the action of a rule.
However, the only locator form allowable for such a declaration is
the very first direct access form:  a name with no '@', '.', '{' or '}'
symbols.


The type of a locator expression is the type of the value it refers to
with one exception.  A locator that refers to a 'sref' variable has type
'str' (unless modified with the unary & operator in which case the
expression has type 'sref').


STATEMENTS
----------

PML has the following types of statements:

 - if ( EXPR ) { STATEMENT_LIST1 } [else { STATEMENT_LIST2 }]

   Evaluate EXPR (typecasting to an int if necessary) and if it is 
   true (non-zero) then execute STATEMENT_LIST1.  If the 'else' clause
   is present and EXPR is false (0), then execute STATEMENT_LIST2
   instead.

 - while ( EXPR ) { STATEMENT_LIST }

   Executes the STATEMENT_LIST while EXPR returns true (non-zero integer).
   (EXPR will be typecast to an integer if possible otherwise the
   compiler will flag an error.)

 - print [% FMT %] EXPR [,[% FMT %] EXPR ...] ;

   Evaluate each EXPR and then print its value.  (the print goes to standard
   error by default when PML is running from the command line.)  If a
   FMT directive is present, then it modifies the output string.  See
   FORMATTED PRINTING.

 - return ;
 - return EXPR ;

   Evaluate EXPR and immediately exit the currently executing function
   and returning the value of EXPR as the return value of the function.
   If EXPR's type doesn't match the return type of the function then PML
   will implicitly confert it if possible or give a compile time error
   if it is not possible.  If the function's return type is 'void' then
   the EXPR must be omitted.  Otherwise EXPR must be included.

 - EXPR ;

   Evaluate and discard the value of EXPR.  (could be a function call
   with side effects.)

 - send ;
 - send EXPR ;

   There are two forms of the 'send' statement.  The first, with no
   expression, sends all of the packets currently in the working set and
   aborts all rule processing on the current packet.  If the EXPR is
   present then the program evaluates EXPR (typecasting to an integer if
   necessary) and sends the packet with the corresponding numeric value.
   The program will abort with an error if EXPR evaluates to an
   erroneous packet number.  After sending, the packet is freed.
   However the program will continue running from the next statement
   after the 'send'.

 - send_no_free EXPR ;

   This statement evaluates EXPR and transmits the packet just as with
   'send EXPR'.  However, with the send_no_free statement, the packet
   remains in the working set.  As with 'send EXPR' execution continues
   after the statement.

 - drop [EXPR] ; 

   As with the 'send' statement, the 'drop' statement has two forms with
   differing control flow semantics.  A 'drop' with no arguments drops
   all packets in the working set and aborts rule processing (starting
   over with the next packet).  If the 'drop' statement has a expression
   argument (EXPR) then the program evaluates the argument typecasting
   the result to an integer and then frees the packet buffer with the
   corresponding numeric index.  As with 'send EXPR', this second form
   of drop continues execution afterwards.  Dropping a packet index that
   is out of range will abort the PML program, but dropping a valid
   packet index that does not actually refer to a packet is simply a
   no-op.

 - break ;

   Immediately jump to the end of the innermost enclosing 'while' loop.
   This will not send control outside of executing functions or rules.
   A break statement outside of any enclosing loop is a compile time
   error.

 - continue ; 

   Immediately jump to the test of the currently innermost loop and 
   evaluate it.  This will not send control outside of the current
   function or rule.  A continue statement outside of any enclosing loop
   is a compile time error.

 - nextrule ;

   Immediately jump to the end of the current rule.  If this occurs
   within a BEGIN rule then this statement will end processing in
   all BEGIN rules.  The same behavior holds for TICK and END rules.  For
   packet rules, this statement directs execution to the test for the next
   rule (or to transmit all remaining packets if no further rules are
   present.)

 - LOCATOR = EXPR ;
   & LOCATOR = EXPR ;

   Evaluate EXPR and assign its value to the location denoted by
   LOCATOR.  LOCATOR and EXPR must have the same type or the PML program
   must be able to type cast the EXPR to the type of LOCATOR.  In 
   assignment statement that is prefixed with a '&', the expression must 
   have type 'sref' and LOCATOR must be a variable of type 'sref'.  This
   assignment modifies the LOCATOR variable to point to refer to a new
   string.


PACKET WORKING SET
------------------

PML keeps a small, fixed size working set of packet buffers during
execution.  The packets are indexed numerically from 0 to 15.
During BEGIN, TICK and END rules the working set start out empty;  none 
of the packet indices refer to live packet buffers.  During packet rules,
PML sets packet index 0 to refer to the next packet that it pulls from
ingress.  The remaining packet indices still refer to nothing.

A PML program can make a packet index refer to a packet buffer by
copying packet buffers or creating packet buffers.  A program creates
new packets with the pkt_new() and pkt_new_z() intrinsics.  It copies
packets with the pkt_copy() intrinsic.  A program can also swap the 
packet buffers that two packet indices refer to through the pkt_swap()
intrinsic.  

In the future, there will also be new intrinsics to save packets to a
backing store and restore them to the working set.  However, this is not
yet implemented.


PROTOCOL NAMESPACES
-------------------

A PML program has access to a set of protocol modules.  These
libraries extend the PML namespace with strings that refer to the
protocols themselves, protocol-specific constants and parsed regions
within packets.  In the ONICS tool-suite, the command-line pml tool uses
the ONICS 'protoparse' and 'ns' APIs to implement these protocol
modules.  

The term 'protocol namespace' refers to the set of symbols that a PML 
protocol module imports into the PML namespace.  Each protocol namespace
has members.  One refers to a member in a namespace by following the
protocol name with a '.' and then the member name.  For example,
"ip.ttl" refers to member "ttl" in the "ip" namespace.  Each protocol
namespace member has one of the following types:
  - namespace	 -- namespaces can nest within each other
  - constant	 -- a constant value with some relationship to the protocol
  - packet field -- a definition of a field within a parsed protocol data unit.

In PML each protocol is assumed to have an encoding format in the
packet.  When each packet arrives in PML, the runtime first decodes it
(using the 'protoparse' library in the CLI version) which produces
offsets to all of the 'protocol data unit's in the packet.  A protocol 
data unit is a set of bytes in the packet that are meaningful in the 
context of a given protocol.  The same bytes in a packet can be members 
of several protocol data units.  For example, a byte the payload of a TCP 
segment might be within a TCP protocol data unit, an IP protocol data unit
and an Ethernet protocol data unit.

When a PML program uses a protocol name as a locator, the locator's
expression type is 'int' and it returns a true or false (1 or 0) value
indicating whether the protocol is present in the given packet (which
defaults to packet index if not specified 0).  If the PML program gives 
the protocol name, but also adds an offset/length substring reference, 
then the locator type is 'str' and it refers to the portion of the packet
encapsulated in that protocol (both header and data).

Every protocol has several members regardless of the protocol type.
These are always accessible to the PML program if the protocol is
present in the packet.  The members for a protocol P are:

  - P.exists -- more explicit form of just plain "P"
  - P.hlen -- the length of the header of the protocol data unit
  - P.plen -- the length of the payload of the protocol data unit
  - P.tlen -- the length of the trailer of the protocol data unit
  - P.totlen -- P.hlen + P.plen + P.tlen
  - P.error -- A bitmap of errors found in the parsing of the protocol
  - P.prid -- the protocol ID of this protocol (will be used in future
              versions for parses referring to groups of protocols such
	      as 'transport' or 'tunnel' to get the actual protocol type)
  - P.index -- the numeric index of the protocol header in the list of
               all the protocol headers (sorted by starting offset).
  - P.header -- A 'str' value referring to the header portion of the data
  - P.payload -- A 'str' value referring to the payload portion of the data
  - P.trailer -- A 'str' value referring to the trailer of the data
  - P.parse -- A 'str' value referring to the entire protocol data unit.
	       (One can access this as P[0] as well.)


Each constant member in a protocol namespace has a type of either 'int', 
'str' or 'mstr'.  An example of such a constant might be "ip.broadcast"
which equals a byte string for 255.255.255.255.

Finally, a packet field member in a protocol namespace provides a way to
access a field within a protocol data unit.  There are two forms of packet
fields:  byte fields and bit fields.  Byte fields have type 'str',
start on a byte boundary and have a length in bits that is a multiple of
8.  Byte fields can have variable lengths.  A bitfield can start at any 
bit in the packet, but its length (in bits) must be fixed and less than 
or equal to 32.  A bitfield's type is 'int', unlike a bytefield.

A PML program can both read and write packet fields in the packet.  The
program must observe rules for assignment based on the type of the
packet field.


FUNCTION DECLARATIONS
---------------------

Functions in PML are subroutines that support direct or indirect 
recursion.  PML functions, like rules, can have local variables and
parameters that are of type 'int' or 'sref'.  A PML program can also
have a prototype declaration of a function to allow other functions to
invoke it before the actual function declaration.

A function prototype takes the form:

  RTYPE NAME ( [TYPE NAME [, TYPE NAME]...] ) ;

The RTYPE can be 'int', 'sref' or 'void'.  Again, 'void' indicates
that there is no return value from the function.

A function declaration has the form:

  RTYPE NAME ( [TYPE NAME [, TYPE NAME]...] ) { STATEMENT_LIST }

Obviously, it is an error for a function declaration not to match its
prototype.  It is also an error to have multiple prototypes that do not
match.

If there are any 'return' statements in the STATEMENT_LIST then the
program will attempt to automatically convert them to the return type of
the function.  This means that if the return type is 'void', then the
program will discard the return value of the return expression (if
present).  If control reaches the end of STATEMENT_LIST without
encountering a return statement, then the program returns a value of '0'
if the return type is 'int' or an empty string reference if the type is
'sref'.  


INLINE DECLARATIONS
-------------------

An 'inline' is a special type of subroutine that must have a return type
of 'int' and whose body is a single expression (that can be type cast to
'int') instead of a list of statements.  Upon invocation, an inline
actually embeds the expansion of the expression in the PML program
directly.  The compiler takes care to evaluate each parameter to the
inline exactly once and the inline can not modify it.  

So an 'inline' is a safe macro for arithmetic computations.  It does not 
have the full cost of performing a function call.  More importantly, the
restrictions on the inline make it trivial to optimize using constant
propagation (see OPTIMIZATION below).  If the arguments to an inline are
known to be constant and all parts of the inline expression depend only
on constants (as opposed to, say, global variables or packet values,
etc..) then the compiler can simply precompute the result of the inline
rather than having the program compute it every time.  This property
also allows the program to invoke inlines in constant definitions.

An inline declaration takes the form:

  inline NAME ( [TYPE NAME [, TYPE NAME]...] ) { EXPR }

Example:

  inline double(int x) { x * x }

  const A = 5;
  const B = double(A);		# legal and gets the value 10
  const C = double(tcp.seq);	# illegal, arg not constant so return value
  				#   isn't constant and can't init a const
  int D;
  { D = double(tcp.seq); }	# legal: call needn't be a constant expr here



FORMATTED PRINTING
------------------

PML's print statement supports formatted printing for nicer display of
output.  A print statement is not required to have a print format.
The formats are:
    %[W]d% - signed decimal (int, default format for 'int' expressions)
    %[W]u% - unsigned decimal (int)
    %[W]x% - unsigned hex (int)
    %[W]o% - unsigned oct (int)
    %[W]b% - binary (int)

    %[W]s% - string (str, length == any, default for 'str' expressions)
    %[W]hex% - hex string (str, length any)
    %[W]ip% - IPv4 address (str, length == 4)
    %[W]ipv6% - IPv6 address (str, length == 16)
    %[W]eth% - 802.11 address (str, length == 6)

 - W is a positive or negative integer.
   * positive = W is the minimum width for the output and
   		output is right justified within that width
   * negative = |W| is the minimum width for the output and
   		the output is left justified within that width


INTRINSICS
----------

Intrinsics are basically functions that operate on resources outside
of those available within the PML language itself.  PML intrinsics allow
the programmer to access properties about strings, manipulate active
packets, manipulate parsed protocol data units, fix checksums and perform
some binary operations quickly.  The intrinsics are given below.


String Operations

  int str_len(sref s)
  	- return the length of a string reference

  int str_addr(sref s)
  	- return the address of a string reference

  int str_ispkt(sref s)
  	- return whether the string reference refers to a packet

  int str_seg(sref s)
  	- return the segment index/packet # that the reference refers to

  int str_isnull(sref s)
  	- return whether the reference is an empty reference


Packet Manipulation

  void pkt_new(int pnum, int len)
  	- create a new packet with 'len' bytes of data

  void pkt_new_z(int pnum, int len)
  	- create a new packet with 0 bytes but 'len' buffer space bytes

  void pkt_swap(int pn1, int pn2)
  	- swap two packets by index

  void pkt_copy(int pndst, int pnsrc)
  	- copy pnsrc to pndst


Packet Buffer / Protocol Unit Manipulation

  void pkt_ins_u(int pnum, int off, int len)
  	- insert 'len' bytes at offset 'off' in packet 'pnum' shifting
	  data up in the buffer

  void pkt_ins_d(int pnum, int off, int len)
  	- insert 'len' bytes at offset 'off' in packet 'pnum' shifting 
	  data down in the buffer

  void pkt_cut_u(sref s)
  	- cut the string from its packet shifting bytes up from the
	  front.  's' must be a reference to packet data.

  void pkt_cut_d(sref s)
  	- cut the string from its packet shifting bytes down from the
	  end.  's' must be a reference to packet data.

  void pkt_parse(int pnum)
  	- reparse a packet 'pnum'

  int pkt_get_off(int pnum, int prid, int idx, int oid)
  	- get offset 'oid' of the 'idx'th protocol data unit with 
	  protocol ID 'prid' in packet 'pnum'

  void pkt_adj_off(int pnum, int prid, int idx, int oid, int amt)
  	- add 'amt' to offset 'oid' of the 'idx'th protocol data unit 
	  with protocol ID 'prid' in packet 'pnum'.

  void parse_push_back(int pnum, int prid)
  	- push a new protocol header of protocol ID 'prid' to the back
	  of the protocol data unit chain of packet 'pnum'.  There must
	  be space within the innermost protocol data unit to hold this
	  new header.  (Use pkt_ins_* of necessary to create it.)

  void parse_pop_back(int pnum)
  	- remove the innermost protocol data unit from packet 'pnum'.
	  This does not remove the data itself: only the parse of the
	  data unit.  To remove the data, follow this up with pkt_cut_*.

  void parse_push_front(int pnum, int prid)
  	- push a new protocol header of protocol ID 'prid' to the front
	  of the protocol data unit chain of packet 'pnum'.  There must
	  be space outside the outermost protocol data unit to hold this
	  new header.  (Use pkt_ins_* of necessary to create it.)

  void parse_pop_front(int pnum)
  	- remove the outermost protocol data unit from packet 'pnum'.
	  This does not remove the data itself: only the parse of the
	  data unit.  To remove the data, follow this up with pkt_cut_*.


  void fix_dltype(pnum)
  	- Set the datalink type of the packet to the outermost protocol
	  data unit's protocol ID.

  void fix_all_len(pnum)
  	- Walk the protocol data units and fix all length fields within
	  each unit.

  void fix_all_csum(pnum)
  	- Walk the protocol data units and fix all the checksum fields
	  within each unit.


Special Locator Intrinsics

  These intrinsics are special in that the user does not provide a
  standard data type as an argument to the intrinsic.  The 'pdesc'
  argument must be a packet locator that refers to a protocol or packet
  field.  Each intrinsic performs an operation on the specific protocol 
  data unit that the locator identifies.

  Examples:
  	tcp		-> the first TCP PDU of packet 0
	@ip{1,2}	-> the 2nd IP PDU of packet 1
	@icmp6{1}	-> the first ICMPv6 PDU of packet 0

  void parse_update(pdesc)
  	- Update the protocol parsed fields for the PDU.  One might use
	  this, for example, after inserting IP option data in an IP
	  header to make PML able to recognize the IP option fields.

  void fix_len(pdesc)
  	- Fix the length fields in the given PDU.

  void fix_csum(pdesc)
  	- Fix the checksum fields in the given PDU.


Numeric Operations

  int pop(int v)
  	- returns the number of bits set in 'v'

  int log2(int v)
  	- returns the position of the first bit set in 'v' or -1 if v
	  == 0.

  int min(int x, int y)
  	- returns the minimum of x and y

  int max(int x, int y)
  	- returns the maximum of x and y


Packet Metadata Intrinsics

  Per packet metadata that may or may not be present in a given packet.
  If the data is not present the meta_get_* function returns -1.
  Similarly, setting the metadata to -1 removes the tag rather than 
  setting it.

  int meta_get_ts_sec(int pnum)
  int meta_get_ts_nsec(int pnum)
  	- get the timestamp in seconds/nano-seconds for packet 'pnum'

  void meta_set_tstamp(int pnum, int sec, int nsec)
  	- set the timestamp for packet 'pnum'

  int meta_get_presnap(int pnum)
  	- get the pre-snapped packet length for packet 'pnum'

  void meta_set_presnap(int pnum, int len)
  	- set the pre-snapped packet length for packet 'pnum' to 'len'

  int meta_get_inport(int pnum)
  	- get the input port for packet 'pnum'.

  void meta_set_inport(int pnum, int port)
  	- set the input port for packet 'pnum' to 'port'.

  int meta_get_outport(pnum)
  	- get the output port for packet 'pnum'.

  void meta_set_outport(pnum, port)
  	- set the output port for packet 'pnum' to 'port'.

  int meta_get_flowid(int pnum)
  	- get the flow identifier of packet 'pnum'.
  	
  void meta_set_flowid(int pnum, int id)
  	- set the flow identifier of packet 'pnum' to 'id'.

  int meta_get_class(int pnum)
  	- get the traffic class of packet 'pnum'.

  void meta_set_class(int pnum, int tc)
  	- set the traffic class of packet 'pnum' to 'tc'.

  int meta_get_seq(int pnum)
  	- get the packet sequence number of packet 'pnum'.

  void meta_set_seq(int pnum, int seq)
  	- set the packet sequence number of packet 'pnum' to 'seq'.

Miscellaneous
  void exit(int status) 
  	- abort program with exit status 'status'.


OPTIMIZATION
------------

The PML compiler has basic optimization support built in.  It
automatically attempts to use constant propagation to simplify
expressions whose values it can determine at compile time.  An
expression is a 'constant expression' if it is:

	- a literal value
	- a const
	- a binary or unary operator whose operands are constant
	  expressions
	- a 'parameter constant inline' all of whose arguments are
	  constant expressions.

A 'parameter constant inline' is an inline whose expression body
would be a constant expression if all of the parameters were constant.

Assume the following declarations:

	inline double(int x) { x * x }
	inline somefunc(int x, int y) { (2 * x) % y }
	inline isHTTP() { tcp and tcp.dport == 80 or tcp.sport == 80 }
	const A = 5;
	int X;


Then, the following are constant expression:
	3
	3 + 5
	3 & 5 * 18
	A / 3
	double(3)
	double(A * 5)
	somefunc(double(3), somefunc(8 * 4 / 2, A))


The following are not constant expressoins:
	X
	double(X)
	tcp
	isHTTP()
	@ip{2}

The inline's double and somefunc are parameter-constant inlines, but
isHTTP is not.  A PML program may assign any constant expression to a 'const'.



RANDOM NOTES
------------
  Types:
    - void			- void (function return type only)
    - signed integer		- int
    - byte string		- str
    - masked byte string	- mstr (NOT DECLARABLE)
    - regular expression	- regex (NOT DECLARABLE)
    - string pointer		- sref
   
  Expressions that can return sref:
    - a location address 
    - a function returning a sref
   

  Currently:
   - local variables have types int, sref
   - parameters can have types int, sref 
   - global variables have types int, str, sref
   - const's have type int
   - functions can return int, sref, str, void
   - inlines can return int
   - intrinsics can return void, int, sref, str, mstr, regex
  
  
  Type casting:
   - in expressions automatic type conversion can go from:
     * maskval (value only)-> bytestr (max 8 bytes BE)-> scalar (discard)-> void
     * sref (discard)-> void
  
   - in assignment:
     * can convert as with expressions
     * can assign scalars to byte strings (overwrite up to 8 bytes)
     * can assign scalars to srefs (overrite up to 8 bytes)
     * can assign byte strings to string refs (string copy)
     * NOTE:
       + sref-to-sref implies rhs uses the '&' operator to get a location address
   

  Value types:
    - local variable    -> scalar, sref
    - parameter	     -> scalar, sref
    - global variable   -> scalar, string, sref
    - constant          -> scalar
    - protocol constant -> scalar, string, masked string
    - protocol name     -> scalar when no offset/length:  boolean indicating
    			   presence of the header
			   byte string when offset length (protocol header)
    - packet field	-> if bitfields then scalar otherwise byte string
    - operator result   -> sref for '&', scalar for all others
    - inline return     -> scalar
    - function return   -> scalar, sref | void


  
  

Byte strings:
  - Named constants can refer to byte strings or mask values
  - Expressions can refer to byte strings or mask values
  - Constant expressions can have constant offsets/lengths into constants.
    * optimization replaces these with a new literal byte string/mask value.
  - Global variables can have a byte string initializer
  - We need read-only space for constant byte strings/mask values that
    the rules and functions refer to.

Code Generation Core:
  - Core is statement list walker:
    * while
    * if
    * return
    * cfm
    * print
   and expression walker:
    * literal
    * locator
    * op
    * call

  - Expression walker can use pmln_walk
  - All expressions push a value onto the stack

Locators (rhs):
  - Literal (symbolic from namespace)
    * Scalar (must not have pkt, idx, off, len)
      - push and be done.. optimized out?
    * Bytestr (must not have pkt, idx)
       - calc off if given:  bounds check?
       - add address (UA)
       - calc (if given) or push length (bounds check?)
    * Maskval (must not have pkt, idx)
       - calc off if given:  bounds check?
       - add value address (UA)
       - add mask address (UA)
       - calc (if given) or push length (bounds check?)
  - Parameter (must not have pkt, idx, off, len)
    * push addr+1 below BP for inlines or addr+2 for functions
  - Local variables (must not have pkt, idx, off, len)
    * push addr above BP for inlines, functions and rules
  - Global variables (must not have pkt, idx)


Each type has a representation on the stack.
  - scalars = 64-bit value 
  - byte strings = 64 bit len then 64-bit UA
  - mask strings = 64 bit len, 64 bit mask addr (UA), 64-bit val addr (UA)
  - string reference = 64-bit len then 64-bit UA
  - in scalar context:
    * for byte strings:  use ldu to convert to scalar
    * for mask strings:  
      ** swap the mask and length, drop the mask, use ldu to get scalar

Functions:
  - function caller should
    * evaluate arguments (reverse order)
    * push the function address
    * invoke 'call'

  - function prolog should:
    * zpush local variables

  - function body
    * evaluate the statement list
    * parameters refs should be ldbp(i) x = 1, y = (addr+2)
    * local variable refs should be ldbp(i) x = 0, y = addr

  - function epilog should
    * a return statement should end each function with a 'x' value of 1
      (for one return value) and a 'w' value of the function arity.
      (return zero implied if not given?)


Inlines:
  - evaluate arguments 
  - invoke pushfr
  - encode expression
    * every parameter ref should be replaced with ldbp(i) x = 1, y = (addr+1)
  - popfr with x = 1, w = number of args


Rules:
  - evaluate pattern
  - push test for zero: if true skip action
  - evaluate action statement list
  - put a 'nextpkt' after the last rule:  (push 1 ; halt)



Intrinsics:
  -- str_len(sref) - return the length of a string reference
  -- str_addr(sref) - return the address of a string reference
  -- str_ispkt(sref) - return whether the string reference refers to a packet
  -- str_seg(sref) - return the segment index/packet # that the ref refers to
  -- str_isnull(sref) - return whether the reference is an empty reference

  -- void pkt_new(pnum, len) - create a new packet with 'len' bytes of data
  -- void pkt_new_z(pnum, len) - create a new packet with 0 bytes but 'len' 
				 buffer space bytes
  -- void pkt_swap(pn1, pn2) - swap two packets by index
  -- void pkt_copy(pndst, pnsrc) - copy pnsrc to pndst
  -- void pkt_del(pnum) - delete a packet

  -- void pkt_ins_u(pnum, off, len) - insert 'len' bytes at 'off' in 'pnum'
				      shifting up
  -- void pkt_ins_d(pnum, off, len) - insert 'len' bytes at 'off' in 'pnum'
				      shifting down
  -- void pkt_cut_u(sref) - cut the string from its packet shifting bytes up
			    from the front
  -- void pkt_cut_d(sref) - cut the string from its packet shifting bytes down
			    from the end
  -- void pkt_parse(pnum) - reparse a packet 'pnum'

  /* very low level functions */
  -- int pkt_get_off(pnum, prid, idx, oid) - get offset 'oid' of the 'idx'th
				'prid' parse in packet 'pnum'
  -- void pkt_adj_off(pnum, prid, idx, oid, amt) - adjust offset 'oid' of the
				'idx'th 'prid' parse in packet 'pnum' by 'adj'

  -- void parse_push_back(pnum, prid)
  -- void parse_pop_back(pnum)
  -- void parse_push_front(pnum, prid)
  -- void parse_pop_front(pnum)
  -- void parse_update(pdesc)

  -- void fix_dltype(pnum)
  -- void fix_len(pdesc)
  -- void fix_all_len(pnum)
  -- void fix_csum(pdesc)
  -- void fix_all_csum(pnum)

  Per packet metadata that may or may not be present.
  If the data is not present the m_get_* function returns -1.
  Similarly, setting to -1 removes the tag rather than setting it.
  -- int  meta_get_tstamp(pnum)
  -- void meta_set_tstamp(pnum, ts)
  -- int  meta_get_presnap(pnum)
  -- void meta_set_presnap(pnum, len)
  -- int  meta_get_inport(pnum)
  -- void meta_set_inport(pnum, port)
  -- int  meta_get_outport(pnum)
  -- void meta_set_outport(pnum, port)
  -- int  meta_get_flowid(pnum)
  -- void meta_set_flowid(pnum, id)
  -- int  meta_get_class(pnum)
  -- void meta_set_class(pnum, tc)
  -- int  meta_get_seq(pnum)
  -- void meta_set_seq(pnum, seq)

  -- void exit(scalar) -- abort program with exit status 'scalar'

  -- int pop(scalar) -- population count of the scalar
  -- int log2(scalar) -- floor of the base 2 log of scalar
  -- int min(scalar1, scalar2)
  -- int max(scalar1, scalar2)

TODO:
  -- int  meta_has(pnum, type, idx)
  -- int  meta_add(pnum, type)
  -- int  meta_rem(pnum, type, idx)
  -- int  meta_get(pnum, type, idx, off, nbytes);
  -- void meta_set(pnum, type, idx, off, nbytes, val);


Formatted printing in PML
 - print [%<fmt>%]<expr> [,[%<fmt>%]<expr> ...]
 - <fmt> is one of:
    %[<w>]d% - signed decimal (scalar, default for scalar)
    %[<w>]u% - unsigned decimal (scalar)
    %[<w>]x% - unsigned hex (scalar)
    %[<w>]o% - unsigned oct (scalar)
    %[<w>]b% - binary (scalar)

    %[<w>]s% - string (byte string, length == any, default for byte string)
    %[<w>]hex% - hex string (byte string, length any)
    %[<w>]ip% - IPv4 address (byte string, length == 4)
    %[<w>]ipv6% - IPv6 address (byte string, length == 16)
    %[<w>]eth% - 802.11 address (byte string, length == 6)
 - <w> is a positive or negative integer.
   * positive = min width right justify
   * negative = min width left justify
   
 - print %-15s:"Hello World\n", %12ipv6:ipv6.daddr;


Metadata:
 PML currently exposes metadata through intrinsics.  It would be
 relatively simple to expose xpkt headers as another type of protocol
 parse.  This was deliberately NOT done at the present time with the
 rationale that PML can exist in environments without xpkt as the core
 packet format.  Furthermore, the user should not be required to know
 xpkt to build and send packets.  (adjusting packets wouldn't be
 impacted much since the fixlen code can take care of common cases.)
 This design choice comes at the expense of ugly intrinsices to access
 the data and less extensibility.  At some point this design choice will
 deserve revisitation.


 - parse info (16, 32, 32)
 - app info (16, 0-1020)
 New locator type?
 Use protoparse for it? 



Regular expressions in NetVM
 - There are a max # of patterns at one time.  All operations get an error
   if the pattern index is out of bounds.
 - Load Pattern [addr, len, idx] -> []
	* frees previous pattern if present
	* May give an error if we run out of memory or if the pattern
	  requires too many matches.
 - Clear Pattern [idx] -> []
 - Match [addr, len, idx] -> [0 or 1]
	* Error if pattern not loaded
 - MatchX [addr, len, nmatch, idx] ->
	[0]
	[offn, offn-1, offn-2 .. off1, pos]
	* Error if pattern not loaded
	* Error if nmatch is too large for the pattern


 

int pkt_splice(sref p, sref b)
{
	if (!str_ispkt(p))
		return -1;
	diff = sref_len(p) - sref_len(b);
	if (diff > 0)
		pkt_cut_d(p[sref_len(p) - diff, diff]);
	} else if (diff < 0) {
		pkt_ins_u(p, sref_len(p), -diff);
	}
	p = b; # string copy
	fix_csum(sref_seg(p));
	return 0;
}


