.TH "pml" 1 "August 2015" "ONICS 1.0"
.SH NAME
pml - Packet Manipulation Language utility to match and modify packets.
.P
.SH SYNOPSYS
\fBpml\fP [\fB-EhiPqsv\fP] [\fB-e\fP \fIexpr\fP]
[\fB-f\fP \fIprogfile\fP] [\fB-I\fP \fIpath\fP] 
[\fIinfile\fP [\fIoutfile\fP]]
.P
\fBpml\fP [\fB-EhiPqv\fP] [\fB-e\fP \fIexpr\fP]
[\fB-f\fP \fIprogfile\fP] \fB-c\fP \fInprgfile\fP
.P
.SH DESCRIPTION
The \fBpml\fP utility invokes the compiler and/or interpreter for the
Packet Manipulation Language (alternately known as the Packet Mangling
Language).  This language is similar to \fBawk(1)\fP or \fBsed(1)\fP for
XPKT streams instead of text records.  By default, \fBpml\fP compiles
the PML program specified in the \fB-e\fP and \fB-f\fP arguments, reads
packets in XPKT format in from standard input, passes them through the 
PML interpreter running the compiled program and then writes the
resulting packets to standard output.  If \fBinfile\fP is specified,
then \fBpml\fP reads the packets from that file instead.  Similarly, if
\fBoutfile\fP is specified, \fBpml\fP writes the output packets to that
file instead.  Both error information from the execution environment and
information printed by the PML program go to standard error.
.P
When the \fB-c\fP option is present, \fBpml\fP acts as a compiler only
and generates a program file that can be run in the same way on packets
using the nvmp(1) program.  In this mode of operation, most of the other
command line options are ignored and the program should not specify an
\fIinfile\fP or \fIoutfile\fP parameter.
.P
The PML language is designed to make the following operations both
simple and scriptable:
.IP *
filtering out packets or selecting a subset of packets from a stream
.IP *
complex pattern matching on packets
.IP *
accessing the parsed packet headers
.IP *
modifying packet contents both in the headers and in the packet payload
.IP *
generating new packets
.IP *
tagging packets with metadata for other tools to use
.P
The ONICS tool suite contains many scripts that make heavy use of PML
for the heavy lifting of their processing.  These programs are easily
implementable using the same ONICS APIs in C programs but have simple
expressions as simple bourne/bourne-again/korn-shell scripts.
.P
The \fBpml\fP command compiles programs to the NetVM virtual machine
interpreter.  See nvmas(1) and nvmpf(1) for more details about the
design of this VM and its features.
.P
.SH OPTIONS
.P
.IP "\fB-c\fP \fInprgfile\fP"
Do not run the PML program on packets.  Rather, compile the PML program
to a NetVM program and save it in \fInprgfile\fP (usually has the .nprg
extension).
.IP "\fB-e\fP \fIexpr\fP"
Add \fIexpr\fP to the list of PML statements to compile.  This option
can appear multiple times.  \fBpml\fP compiles the final program from
the code that the \fB-e\fP and \fB-f\fP arguments specify in the order
they were given on the command line.
.IP \fB-E\fP
Ignore run-time errors that the VM detects in the program.  When such an
error occurs, simply drop the current packet set and move onto the next
packet.  If this flag is not present \fBpml\fP will abort when it
encounters such an error.  Run-time errors including trying to access
packet fields that are not present or accessing a byte string out of
bounds (preventable by proper checking in the program).
.IP "\fB-f\fP \fIprogfile\fP"
Add \fIprogfile\fP to the list of PML program files to compile.
\fBpml\fP compiles the final program from the code that the \fB-e\fP and
\fB-f\fP arguments specify in the order they were given on the command
line.
.IP \fB-h\fP
Print the usage of the command and exit.
.IP \fB-i\fP
Automatically import standard PML libraries for the program.  This is
semantically equivalent to placing \fB-e 'import "std.pml";'\fP in
the command line arguments before any other \fB-e\fP or \fB-f\fP
arguments.
.IP "\fB-I\fP \fIpath\fP"
Add \fIpath\fP to the search path for import statements.  This option
can appear multiple times.  The PML compiler will always search for an
imported file first in the current directory, next in any directories
specified by the \fB-I\fP option in the order they appear on the command
line and finally in the system library directory.  One can omit the
system library from the search path using the \fB-P\fP option (below).
The system library path is system dependent but usually defaults to 
something like /usr/local/lib/pml.
.IP \fB-P\fP
Omit the standard system PML library from the path for import
statements.
.IP \fB-q\fP
Decrease the verbosity.  Can be specified multiple times.
.IP \fB-s\fP
Single step the PML program in the NetVM interpreter.  This option
mainly has meaning when the verbosity is increased to the degree that,
when this option is specified, \fBpml\fP will output the individual
instructions that it executes along with stack traces.  This is, of
course, mainly a debugging feature.
.IP \fB-v\fP
Increase the verbosity.  Can be specified multiple times.
.P
.SH "THE PML LANGUAGE"
The Packet Manipulation Language is a simple scripting language
intended to be similar to 'awk' for packet streams instead of text
records.  The PML implementation in this distribution compiles to the
NetVM virtual machine.  Like AWK, PML programs consist of three
sections, the 'BEGIN segment' that executes at program start, the
\'packet segment' that executes on once on every packet and the 'END
segment' that executes after the program receives notification that no
further packets will arrive.  Unlike AWK, PML programs can also contain
a 'TICK segment' that executes once per millisecond to handle simple
timing events.
.P
The packet segment consists of a series of rules each with a pattern and
an action.  Each packet gets compared against the rules sequentially.
If the packet matches the pattern then the program executes the rule
action.  A rule action can execute multiple statements.  These
statements can include operations to create and delete packets.  They
can also halt processing on the current packet to circumvent the
remaining rules.
.P
PML supports an extensible namespace for packet protocols.  When a
programmer generates the definitions for parsing a protocol, defining
its fields and its constants through the ONICS protoparse framework, the
PML parser automatically picks up those definitions and allows the PML
programmer to access them.  The upshot of all of this for PML is that
the actual "vocabulary" of a PML program depends on the protocol
definitions that the PML compiler/interpreter loads.  This makes the
language readily extensible to new protocols.  The NetVM can support and
future work will include making the protocol namespaces and fields
discoverable and allowing access to packet fields based on protocol
identifiers and indices, rather than field names.  The current ONICS
toolkit includes protocol definitions for Ethernet II, IP, IPv6, ICMP,
ICMPv6, UDP and TCP protocols.
.P
PML has six basic data types: signed 32-bit integers (int), byte strings
(str), byte string references (sref), masked byte strings, regular
expressions and the void type.  However, PML can only store a subset of
these types in variables.  A PML global variable can hold a int, str or
sref.  A PML local variable or parameter can only hold an int or sref.
Masked byte strings and regular expressions are only available as
literal constants (currently).  The void type can only be a return type
for a function.
.P
PML also supports named constants.  A program can not modify a constant
value and said value may not have any associated memory space in the
final program.  These values are used like #defines in the C language.
A program can define these symbols as PML expressions as long as the
expression itself is constant and the compiler can determine its final
value at compile time.  Thus a program can define a constant in terms of
operations on other constants.
.P
PML has three types of subroutines all of which take a fixed number of
parameters.  A function subroutine can return a scalar, reference or a
void value (meaning no return type).  A function executes a list of
statements and can be recursive or mutually recursive with another
function.
.P
An 'inline macro' contains only a single scalar expression and can not
be recursive.  PML inline macros are safe macros without side effects.
The compiler can even use constant propagation to determine an inline
macro result at compile time provided every parameter to the inline
macro is constant.  Inline macros can invoke other inline macross but,
again, can not recurse directly or indirectly.  An inline macro can
invoke a function that invokes the inline macro.  But this will not
result in an inline macro expansion past the function call so the inline
macro itself is not recursive.  The function in that case, however, is.
.P
An 'intrinsic' is a subroutine whose definition is outside of the PML
language.  This provides function-style syntax for operations that the
PML program simply can not perform, but needs access to.  The PML
language defines intrinsics for accessing packet metadata, manipulating
packet buffers, manipulating packet parses, premature program exit and
accelerated bit operations.  An intrinsic returns an int or void but in
it is possible for one to return any data type including those not
usually available to functions.
.P
.SS "PROGRAM SYNTAX"
At the highest level, a PML program consists of a set of declarations.
Each declaration can declare:
.IP "*"
a rule
.IP "*"
a function prototype (needed for recursion)
.IP "*"
a function definition
.IP "*"
an inline macro
.IP "*"
a constant
.IP "*"
a global variable 
.IP "*"
a file import 
.P
.SS "COMMENTS"
Comments in PML start with a '#' that isn't in a string constant and
they continue until the end of the line.
.P
.SS "FILE IMPORT"
.P
A file import takes the form:
.nf
  'import' "FILENAME" ';'
.fi
The parser will search for the import file along a search path.  The
\fBpml\fP program begins its search in the current directory and then
will continue to the directory \fIprefix\fP/lib/pml where \fIprefix\fP
is the installation prefix where the ONICS tool suite is installed.  If
the PML parser fails to find the import file it will abort with an
error.  Otherwise it will include the contents of the import file as if
it were directly substituted in the place of the import line itself.
.P
.SS "RULES"
.P
A rule definition take the form:
.P
.nf
  RULE ::= PATTERN '{' [LOCAL_VAR_DECL]* [STATEMENT_LIST]* '}'
.fi
.P
A PATTERN must be one of 'BEGIN', 'TICK', 'END' or a PML expression 
enclosed by '?-' and '-?'.  The order of rule declaration matters because
the PML program executes rules in their declaration order.  There can be 
multiple rules with the 'BEGIN', 'TICK' and 'END' pattern.  PML executes 
rules with the 'BEGIN' pattern at startup before any packets are read in
the system.  PML executes the 'TICK' segment, if present, once every
millisecond.  It exectues rules with the 'END' pattern after it determines
that there are no further packets to process.  Note that the exit()
intrinsic will abort execution immediately and the program will not
execute rules in the 'END' pattern that it has not already executed.
If the program contains a 'TICK' segment, but no packet rules, then the
program runs until the 'TICK' segment invokes the exit() intrinsic.
.P
PML evaluates a rule with an expression pattern once for every packet
that it receives.  The PML program evaluates the PATTERN exression (the
\'rule pattern').  If the expression returns non-zero scalar result then
the program executes the STATEMENT_LIST (the 'rule action').  It is also 
worth noting that PML can coerce any type to an integer value (see below)
so any PML expression is valid in a rule pattern.  Again, PML evaluates
the rules in order and a rule's actions (in the STATEMENT_LIST) can cause
the program to skip later rules.  So order of declaration is important.  
A PML program can omit the pattern expression which will cause the rule
action to fire on every packet.
.P
The LOCAL_VAR_DECL is an optional series of local variable declarations.
These are discussed in the next section.
.P
If PML comes to the end of the packet rules without any other statement
that aborts control on the current packet (see STATEMENTS), then
PML will transmit all packets remaining in the working set.  (see PACKET
WORKING SET)
.P
.SS "TYPES"
PML supports the following native types:
.nf
 - void  -> no type or value
 - int   -> signed 32-bit integer
 - str   -> byte string
 - sref  -> reference to a byte string 
	    (declared as a 'str' with no length)
 - mstr  -> byte string with equal length byte string mask
 - regex -> regular expression
.fi
.P
The void type may only be used for a function return value.  The program
can not contain variables of type mstr and regex.  A program can contain
constant masked string and regular expression patterns.  But it can not
store them in variables.  Local variables and function parameters may not
be byte strings, but may be string references.  Only global varaibles
may be byte strings.  
.P
.SS "VARIABLE DECLARATIONS"
PML allows one to declare four types of variables:  global variables,
local variables, function parameters and constants.  A global variable
is the only variable that can have a byte string type.  It can also have
a type of \'int' or 'sref'.  A global variable declaration has one of
the following forms.
.P
.nf
  int NAME [= EXPRESSION] ;
  str NAME ;
  str NAME '[' LENGTH ']' [= EXPRESSION] ;
  str NAME '[' ']' = EXPRESSION ;
.fi
.P
The first form declares a 32-byte integer variable.  If EXPRESSION is
present, then the variable is initialized to the value of the
expression.  Otherwise it is initialized to 0.  The second form declares
a globally accessible string reference.  Note that although it uses the
keyword 'str' like a byte string, the lack of '[]'s means that it is a
reference to a string and not an actual byte strings.  A string
reference can not have an initializer at compile time.
.P
The third form of declaration declares a byte string of LENGTH bytes.
If EXPRESSION is present, then the string is initialized to the value of
the expression (which must be of type 'str').  If the variable has a
longer length than the initialization expression, then the program
initializes the remaining bytes in the string are initialized to 0.  If
the initializer is greater in length than the variable then the compiler
will report an error.  A byte string variable without an initializer
will initially contain all 0s in every byte.  The fourth form declares a
byte string variable and sets its length to the length of its
initializer.  The initializer can be a protocol constant, scalar or
literal string.  Substring access to protocol constants or literal
strings is not supported.
.P
A program can have local variable declarations at the beginning of the
action portions of a rule or the body of a function.  Variable
declarations may not appear in inline macross.  Again, as mentioned,
local variables can be integers and string references.  A rule action or
function body may use variables of type 'int' without declaring them.
Referencing a variable name in a function body or rule action statement
that has no binding to a previously declared variable or
protocol-specific name (see \'LOCATORS' below) automatically declares a
local variable of type 'int'.  Local variables may not have
initializers.
.P
PML initializes all uninitialized variables to 0 (int), a string of 0s
(str) or a null reference (sref) depending on the variable type.
.P
.SS "EXPRESSIONS"
In the following, let 'E', 'E1', 'E2' ... refer to expressions.  Tokens of 
the form *LOC refers to a 'locator'.  This is an rvalue consisting of a 
variable name or a protocol namespace constant.  
.P
In PML an expression is one of:
.nf
  - a positive decimal integer
  - a hexadecimal integer preceeded by '0x'
  - a locator (see below)
  - a function or inline macro call of the form:
	<funcname> '(' [E1, E2...] ')'
  - a literal byte string:  
	a double quoted string with usual C substitutions
	  OR
  	'\\x' followed by an even number of hex digits
	  OR
	a dotted quad IPv4 address (4 byte string)
	  OR
	an IPv6 address (16 byte string)
	  OR
	an 802.1 MAC address (6 byte string)

  (In order of precedence)

  - '(' E ')'   : parenthesized expression
  - '-' E       : numerically negated expression
  - 'not' E	: logcal inversion (value is 0 or 1)
  - '~' E	: binary inversion (bit-wise inversion)
  - E1 << E2	: E1 left-shifted by E2
  - E1 >> E2	: E1 right-shifted by E2
  - E1 % E2	: E1 modulo E2
  - E1 / E2	: E1 divided by E2
  - E1 * E2	: E1 multiplied by E2
  - E1 + E2	: E1 plus E2
  - E1 - E2	: E1 minus E2
  - E1 & E2	: E1 binary-ANDed with E2
  - E1 | E2	: E1 binary-ORed with E2
  - E1 ^ E2	: E1 binary-XORed with E2
  - E1 == E2	: E1 equals E2 (numeric or string compare)
  - E1 != E2	: E1 does not equal E2 (numeric or string compare)
  - E1 < E2	: E1 less than E2 (numeric compare)
  - E1 > E2	: E1 greater than E2 (numeric compare)
  - E1 <= E2	: E1 less or equal to E2 (numeric compare)
  - E1 >= E2	: E1 greater or equal to E2 (numeric compare)
  - E1 =~ E2	: E1 matches E1
  - E1 !~ E2	: E1 does not match E2
  - E1 'and' E2 : E1 and E2 (short circuit boolean compare)
  - E1 'or ' E2 : E1 or E2 (short circuit boolean compare)
.fi
.P
The type of an expression is usually 'int'.  However, there are several
exceptions.  A byte string literal has type 'str'.  A function or inline
macro call has a type of the return value of the function or inline
macro (always 'int' for inline macros).  A locator expression's type is
equal to the type value that the locator refers to.  All string
references used in expressions have type 'str'.
.P
The match comparison operators (=~ and !~) perform different comparisons
depending on the type of the right hand expression.  The left-hand 
expression must have a type of str or sref.  The right hand expression
must have type str, mstr or regex.  For the rest of this discussion
Let E1 be the left-hand side expression in the match expression and 
let E2 be the right-hand side.
.P
If E2 has type 'str', then PML performs an exact string comparison (the
lengths of the E1 and E2 must be equal in order to be equal).  If the
E2 has type 'mstr' then PML performs a masked string comparison.  A
masked string value has a 'value' component and a 'mask' component both
of which are byte strings.  Both 'value' and 'mask' must have the same
length.  Expression E1 matches an mstr E2 if and only if: 1) the length of
E1 matches the lengths of E2's value and mask and 2) each bit b1 in
E1 matches its corresponding bit b2 in E2.value when the corresponding 
bit 'm' in E2.mask is set.  Finally, if E2 has type regex then PML
performs a regular expression mask of the pattern E2 against E1.
.P
Aside from the match and reference operators, all other operators
require the types of their subexpressions to be 'int'.  Each expression
argument in a function or inline macro call must have the same type as
the corresponding formal paramenter in the function declaration.
.P
.SS "TYPE CONVERSION"
PML will automatically attempt to convert an expression to the type
required by a given operator or function parameter.  PML will also try
to implicitly convert the expression in a 'return' statement (see below)
to the return type of the enclosing function.  The language performs the
following type conversion implicitly:
.P
.nf
  mstr->str - returns the 'value' portion of the masked string

  str->int  - treat up to the first 4 bytes of the string as a big
              endian 2s-compliment arithmetic integer.  If the string
              is less than 4 bytes, logcially pad to 4 bytes with
              zeros in the high order bits.

  mstr->int - convert the value and the mask of the masked string
              to 'int' as above and return the binary AND of the
              two resulting values.

  str->sref - converts the string to a reference to the string.
              This can occur in three ways:
                1) when assigning a 'str' valued expression to an 
                   'sref' variable by the '& VAR = EXPR' statement.
                2) when passing a string to an sref parameter
                   (denoted with type 'str') in a function call.
                3) when returning a string in a function call with
                   declared return type 'str' (which means sref in
                   function call return types).

  str->void - discards the value
  int->void
  sref->void
  mstr->void
.fi
.P
.SS "STATEMENTS"
PML has the following types of statements:
.nf

 - if ( EXPR ) { STATEMENT_LIST1 } [else { STATEMENT_LIST2 }]

   Evaluate EXPR (typecasting to an int if necessary) and if it is 
   true (non-zero) then execute STATEMENT_LIST1.  If the 'else' clause
   is present and EXPR is false (0), then execute STATEMENT_LIST2
   instead.

 - while ( EXPR ) { STATEMENT_LIST }

   Executes the STATEMENT_LIST while EXPR returns true (non-zero 
   integer).  (EXPR will be typecast to an integer if possible 
   otherwise the compiler will flag an error.)

 - print [% FMT %] EXPR [,[% FMT %] EXPR ...] ;
   print [% FMT %] EXPR [,[% FMT %] EXPR ...] , ;

   Evaluate each EXPR and then print its value.  (the output goes to 
   standard error by default when PML is running from the command
   line.)  If a FMT directive is present, then it modifies the output
   string.  See FORMATTED PRINTING.  A print statement without a trailing
   comma automatically appends a newline after printing all of the 
   expressions.  If trailing comma (between the last expression and
   the semicolon) is present, then the statement does not add a newline
   to the end of the printing.

 - return ;
 - return EXPR ;

   Evaluate EXPR and immediately exit the currently executing function
   and returning the value of EXPR as the return value of the function.
   If EXPR's type doesn't match the return type of the function then PML
   will implicitly confert it if possible or give a compile time error
   if it is not possible.  If the function's return type is 'void' then
   the EXPR must be omitted.  Otherwise EXPR must be included.

 - EXPR ;

   Evaluate and discard the value of EXPR.  (could be a function call
   with side effects.)

 - send ;
 - send EXPR ;

   There are two forms of the 'send' statement.  The first, with no
   expression, sends all of the packets currently in the working set and
   aborts all rule processing on the current packet.  If the EXPR is
   present then the program evaluates EXPR (typecasting to an integer if
   necessary) and sends the packet with the corresponding numeric value.
   The program will abort with an error if EXPR evaluates to an
   erroneous packet number.  After sending, the packet is freed.
   However the program will continue running from the next statement
   after the 'send'.

 - send_no_free EXPR ;

   This statement evaluates EXPR and transmits the packet just as with
   'send EXPR'.  However, with the send_no_free statement, the packet
   remains in the working set.  As with 'send EXPR' execution continues
   after the statement.

 - drop [EXPR] ; 

   As with the 'send' statement, the 'drop' statement has two forms with
   differing control flow semantics.  A 'drop' with no arguments drops
   all packets in the working set and aborts rule processing (starting
   over with the next packet).  If the 'drop' statement has a expression
   argument (EXPR) then the program evaluates the argument typecasting
   the result to an integer and then frees the packet buffer with the
   corresponding numeric index.  As with 'send EXPR', this second form
   of drop continues execution afterwards.  Dropping a packet index that
   is out of range will abort the PML program, but dropping a valid
   packet index that does not actually refer to a packet is simply a
   no-op.

 - break ;

   Immediately jump to the end of the innermost enclosing 'while' loop.
   This will not send control outside of executing functions or rules.
   A break statement outside of any enclosing loop is a compile time
   error.

 - continue ; 

   Immediately jump to the test of the currently innermost loop and 
   evaluate it.  This will not send control outside of the current
   function or rule.  A continue statement outside of any enclosing loop
   is a compile time error.

 - nextrule ;

   Immediately jump to the end of the current rule.  If this occurs
   within a BEGIN rule then this statement will end processing in
   all BEGIN rules.  The same behavior holds for TICK and END rules.  For
   packet rules, this statement directs execution to the test for the next
   rule (or to transmit all remaining packets if no further rules are
   present.)

 - LOCATOR = EXPR ;
   Evaluate EXPR and assign its value to the location denoted by
   LOCATOR.  LOCATOR and EXPR must have the same type or the PML program
   must be able to type cast the EXPR to the type of LOCATOR. 

 - & VARIABLE = EXPR ;
   Evaluate EXPR which must have 'str' type.  This assigns the string
   reference to the returned string to the given VARIABLE which must
   be of type 'sref'.
.fi
.P
.SS "LOCATORS"
A locator is a named reference to a value.  The name may refer to a
variable, a protocol, a field in a packet or a constant.  A locator can
have the following forms:
.P
.SS "Direct Access"
.nf
  name          -- can refer to: variable, constant, packet field,
                   protocol, or protocol constant

  name.name2[...]
                -- can refer to: packet field, protocol or 
                   protocol constant

  $(pnum)name
  $(pnum)name.name2...
  $(pnum,idx)name
  $(pnum,idx)name.name2...
                -- can refer to: packet field
.fi
.P
At a given point in the PML program, the compiler consults the following
namespaces in the following order to determine which value a locator
refers to: protocol namespace, parameters, constants global variables,
local variables.  Recall from VARIABLES above, that a locator matches
none of the above namespaces will implicitly cause a local variable
declaration if the reference is in the body of a function or the action
of a rule.  However, the only locator form allowable for such a
declaration is the very first direct access form:  a name with no
\'$', '.', '(' or ')' symbols.
.P
The type of a locator expression is the type of the value it refers to
with one exception.  A locator that refers to a 'sref' variable has type
\'str' in all r-values.
.P
A direct access locator that begins with $(pnum) or $(pnum, idx) refers
can refer to packets other than packet 0 in the working set (see below).
The value 'pnum' (which need not be constant) selects the packet number
in the working set.  If 'idx' is specified, it gives the header index to
select starting from 1.  So the locator '$(1,2)tcp' refers to the 2nd
TCP header in the second packet (packet 1) in the working set.
.P
.SS "Substring Access"
A program can access any non-empty substring of a str or sref type
locator.  ('SLOC' below refers to any direct access string locator given
in the previous section.)  One can provide an offset or an offset and
length to specify the substring.  Both values can be arbitrary
expressions as long as they can be converted to type int.  Specifying an
invalid substring (e.g. a negative offset or length, or an offset or
length that is out of bounds for the string) will trigger a run-time
error and abort the program.
.P
.nf
  SLOC[off]	
  SLOC[off, len]	
		-- could refer to: variable, protocol, protocol
		   constant packet field.
.fi
.P
.SS "Protocol ID"
.nf
  @@name
  @@name.name2	-- could refer to: protocol name
.fi
.P
.P
.SS "PACKET WORKING SET"
PML keeps a small, fixed size working set of packet buffers during
execution.  The packets are indexed numerically from 0 to 15.  During
BEGIN, TICK and END rules the working set start out empty;  none of the
packet indices refer to live packet buffers.  During packet rules, PML
sets packet index 0 to refer to the next packet that it pulls from
ingress.  The remaining packet indices still refer to nothing.
.P
A PML program can make a packet index refer to a packet buffer by
copying packet buffers or creating packet buffers.  A program creates
new packets with the pkt_new() and pkt_new_z() intrinsics.  It copies
packets with the pkt_copy() intrinsic.  A program can also swap the
packet buffers that two packet indices refer to through the pkt_swap()
intrinsic.  
.P
.SS "PROTOCOL NAMESPACES"
A PML program has access to a set of protocol modules.  These libraries
extend the PML namespace with strings that refer to the protocols
themselves, protocol-specific constants and parsed regions within
packets.  In the ONICS tool-suite, the command-line pml tool uses the
ONICS 'protoparse' and 'ns' APIs to implement these protocol modules.  
.P
The term 'protocol namespace' refers to the set of symbols that a PML 
protocol module imports into the PML namespace.  Each protocol namespace
has members.  One refers to a member in a namespace by following the
protocol name with a '.' and then the member name.  For example,
"ip.ttl" refers to member "ttl" in the "ip" namespace.  Each protocol
namespace member has one of the following types:
.nf
  - namespace    -- namespaces can nest within each other
  - constant     -- a constant value with some relationship 
                    to the protocol
  - packet field -- a definition of a field within a parsed 
		    protocol data unit.
.fi
.P
In PML each protocol is assumed to have an encoding format in the
packet.  When each packet arrives in PML, the runtime first decodes it
(using the 'protoparse' library in the CLI version) which produces
offsets to all of the 'protocol data unit's in the packet.  A protocol 
data unit is a set of bytes in the packet that are meaningful in the 
context of a given protocol.  The same bytes in a packet can be members 
of several protocol data units.  For example, a byte the payload of a TCP 
segment might be within a TCP protocol data unit, an IP protocol data unit
and an Ethernet protocol data unit.
.P
When a PML program uses a protocol name as a locator, the locator's
expression type is 'int' and it returns a true or false (1 or 0) value
indicating whether the protocol is present in the given packet (which
defaults to packet 0 if not specified).  If the PML program gives 
the protocol name, but also adds an offset/length substring reference, 
then the locator type is 'str' and it refers to the portion of the packet
encapsulated in that protocol (both header and data).
.P
Every protocol has several members regardless of the protocol type.
These are always accessible to the PML program if the protocol is
present in the packet.  The members for a protocol P are:
.P
.nf
  - P.exists -- more explicit form of just plain "P"
  - P.hlen   -- the length of the header of the protocol data unit
  - P.plen   -- the length of the payload of the protocol data unit
  - P.tlen   -- the length of the trailer of the protocol data unit
  - P.totlen -- P.hlen + P.plen + P.tlen
  - P.error  -- A bitmap of errors found in the parsing of the protocol
  - P.prid   -- the protocol ID of this protocol (will be used in future
                versions for parses referring to groups of protocols 
                such as 'transport' or 'tunnel' to get the actual 
                protocol type)
  - P.index  -- the numeric index of the PDU in the list of all the 
                PDUs in the packet (sorted by starting offset).
  - P.header -- A 'str' value referring to the header of the PDU
  - P.payload-- A 'str' value referring to the payload of the PDU
  - P.trailer-- A 'str' value referring to the trailer of the PDU
  - P.parse  -- A 'str' value referring to the entire PDU.
                (One can access this as P[0] as well.)
.fi
.P
Each constant member in a protocol namespace has a type of either 'int', 
\'str' or 'mstr'.  An example of such a constant might be 
"ip.addr.broadcast" which equals a byte string for 255.255.255.255.
.P
Finally, a packet field member in a protocol namespace provides a way to
access a field within a protocol data unit.  There are two forms of packet
fields:  byte fields and bit fields.  Byte fields have type 'str',
start on a byte boundary and have a length in bits that is a multiple of
8.  Some byte fields can have variable lengths.  A bitfield can start at 
any bit in the packet, but its length (in bits) must be fixed and less than 
or equal to 32.  A bitfield's type is 'int', unlike a bytefield.
.P
A PML program can both read and write packet fields in the packet.  The
program must observe rules for assignment based on the type of the
packet field.
.P
.SS "FUNCTION DECLARATIONS"
Functions in PML are subroutines that support direct or indirect 
recursion.  PML functions, like rules, can have local variables and
parameters that are of type 'int' or 'sref'.  A PML program can also
have a prototype declaration of a function to allow other functions to
invoke it before the actual function declaration.
.P
A function prototype takes the form:
.P
.nf
  RTYPE NAME ( [TYPE NAME [, TYPE NAME]...] ) ;
.fi
.P
The RTYPE can be 'int', 'str' or 'void'.  Again, 'void' indicates
that there is no return value from the function.  The 'str' type
indicates that the function returns a string references.
.P
A function declaration has the form:
.P
.nf
  RTYPE NAME ( [TYPE NAME [, TYPE NAME]...] ) { STATEMENT_LIST }
.fi
.P
Obviously, it is an error for a function declaration not to match its
prototype.  It is also an error to have multiple prototypes that do not
match.
.P
If there are any 'return' statements in the STATEMENT_LIST then the
program will attempt to automatically convert them to the return type of
the function.  This means that if the return type is 'void', then the
program will discard the return value of the return expression (if
present).  If control reaches the end of STATEMENT_LIST without
encountering a return statement, then the program returns a value of '0'
if the return type is 'int' or an empty string reference if the type is
\'sref'.  
.P
.SS "INLINE MACRO DECLARATIONS"
An 'inlinemacro ' is a special type of subroutine that must have a
return type of 'int' and whose body is a single expression (that can be
type cast to 'int') instead of a list of statements.  Upon invocation,
an inline macro actually embeds the expansion of the expression in the
PML program directly.  The compiler takes care to evaluate each
parameter to the inline macro exactly once and the inline macro can not
modify it.  
.P
So an 'inline macro' is a safe macro for arithmetic computations.  It
does not have the full cost of performing a function call.  More
importantly, the restrictions on the inline macro make it possible to
optimize using constant propagation (see OPTIMIZATION below).  If the
arguments to an inline macro are known to be constant and all parts of
the inline macro expression depend only on constants (as opposed to,
say, global variables or packet values, etc..) then the compiler can
simply precompute the result of the inline macro rather than having the
program compute it every time.  This property also allows the program to
invoke inline macros in constant definitions.
.P
An inline macro declaration takes the form:
.P
.nf
  inline NAME ( [TYPE NAME [, TYPE NAME]...] ) { EXPR }
.fi
.P
Example:
.P
.nf
  inline double(int x) { 2 * x }

  const A = 5;
  const B = double(A);          # legal and gets the value 10
  const C = double(tcp.seq);    # illegal, arg not constant so return 
                                #   value isn't known and can't 
                                #   initialize a const
  int D;
  { D = double(tcp.seq); }      # legal: call needn't be a constant 
                                #   expr here
.fi
.P
.SS "FORMATTED PRINTING"
PML's print statement supports formatted printing for nicer display of
output.  A print statement is not required to have a print format.
The formats are:
.nf

    %[W]d% - signed decimal (int, default format for 'int' expressions)
    %[W]u% - unsigned decimal (int)
    %[W]x% - unsigned hex (int)
    %[W]o% - unsigned oct (int)
    %[W]b% - binary (int)

    %[W]s% - string (str, length == any, default for 'str' expressions)
    %[W]hex% - hex string (str, length any)
    %[W]ip% - IPv4 address (str, length == 4)
    %[W]ip6% - IPv6 address (str, length == 16)
    %[W]eth% - 802.11 address (str, length == 6)

 - W is a positive or negative integer.
   * positive = W is the minimum width for the output and
   		output is right justified within that width
   * negative = |W| is the minimum width for the output and
   		the output is left justified within that width
.fi
.P
.SS "INTRINSICS"
Intrinsics are basically functions that operate on resources outside
of those available within the PML language itself.  PML intrinsics allow
the programmer to access properties about strings, manipulate active
packets, manipulate parsed protocol data units, fix checksums and perform
some bit operations quickly.  The intrinsics are given below.
.P
.SS "String Operations"
.P
.nf
  int str_len(str s)
  	- return the length of a string reference

  int str_addr(str s)
  	- return the address of a string reference

  int str_ispkt(str s)
  	- return whether the string reference refers to a packet

  int str_seg(str s)
  	- return the segment index/packet # that the reference refers to

  int str_isnull(str s)
  	- return whether the reference is an empty reference
.nf
.P
.SS "Packet Manipulation"
.nf
  void pkt_new(int pnum, int len)
  	- create a new packet with 'len' bytes of data

  void pkt_new_z(int pnum, int len)
  	- create a new packet with 0 bytes but 'len' buffer space bytes

  void pkt_swap(int pn1, int pn2)
  	- swap two packets by index

  void pkt_copy(int pndst, int pnsrc)
  	- copy pnsrc to pndst
.fi
.P
.SS "Packet Buffer / Protocol Unit Manipulation"
.nf
  void pkt_ins_u(int pnum, int off, int len)
  	- insert 'len' bytes at offset 'off' in packet 'pnum' shifting
	  data up in the buffer

  void pkt_ins_d(int pnum, int off, int len)
  	- insert 'len' bytes at offset 'off' in packet 'pnum' shifting 
	  data down in the buffer

  void pkt_cut_u(str s)
  	- cut the string from its packet shifting bytes up from the
	  front.  's' must be a reference to packet data.

  void pkt_cut_d(str s)
  	- cut the string from its packet shifting bytes down from the
	  end.  's' must be a reference to packet data.

  void pkt_parse(int pnum)
  	- reparse a packet 'pnum'

  int pkt_get_off(int pnum, int prid, int idx, int oid)
  	- get offset 'oid' of the 'idx'th protocol data unit with 
	  protocol ID 'prid' in packet 'pnum'

  void pkt_adj_off(int pnum, int prid, int idx, int oid, int amt)
  	- add 'amt' to offset 'oid' of the 'idx'th protocol data unit 
	  with protocol ID 'prid' in packet 'pnum'.


  void fix_dltype(pnum)
  	- Set the datalink type of the packet to the outermost protocol
	  data unit's protocol ID.

  void fix_lens(pnum)
  	- Walk the protocol data units and fix all length fields within
	  each unit.

  void fix_csums(pnum)
  	- Walk the protocol data units and fix all the checksum fields
	  within each unit.
.fi
.P
.SS "Packet Storage and Retrieval"
The PML runtime environment allows storing a packets in lists.  These
lists can persist between execution contexts.  Normally, at the end of a
BEGIN, TICK or END rule or after the last packet rule executes, the
runtime transmits all packets in the working set.  (This holds true if the
packet rules terminate early due to a 'send' statement.)  A program can
instead stash packets in numbered lists in either a first-in-first-out
(FIFO) or last-in-first-out (LIFO) fashion (or even a combination of the
two) and then retrieve them at a later point.  The number of available
packet lists depends on the runtime, but the program can query it using
\'pkt_nlists()'.  The \fBpml\fP command line application supports 256
separate lists.  If a PML program terminates, the runtime will free all
packets still stored in packet lists.
.P
.nf
  int pkt_nlists()
	- return the number of packet lists in the system.

  int pkt_lempty(int listnum)
	- return whether a given packet list is empty.

  void pkt_enq(int listnum, int pnum)
	- enqueue packet 'pnum' to the end of packet list 'listnum'

  void pkt_deq(int listnum, int pnum)
	- dequeue the next packet from the front of packet list
	  'listnum' to packet 'pnum'

  void pkt_push(int listnum, int pnum)
	- push packet 'pnum' to the front of packet list 'listnum'

  void pkt_pop(int listnum, int pnum)
	- pop the next packet from the front of packet list 'listnum' to
	  packet 'pnum'
.fi
.P
.SS "Special Locator Intrinsics"
  These intrinsics are special in that the user does not provide a
  standard data type as an argument to the intrinsic.  The 'pdesc'
  argument must be a packet locator that refers to a protocol or packet
  field.  Each intrinsic performs an operation on the specific protocol 
  data unit that the locator identifies.
.P
  Examples:
.P
.nf
  	tcp		-> the first TCP PDU of packet 0
	$(1,2)ip	-> the 2nd IP PDU of packet 1
	$(1)icmp6	-> the first ICMPv6 PDU of packet 0
.fi
.P
.nf
  void fix_len(pdesc)
  	- Fix the length fields in the given PDU.

  void fix_csum(pdesc)
  	- Fix the checksum fields in the given PDU.

  void pdu_update(pdesc)
  	- Update the protocol parsed fields for the PDU.  One might use
	  this, for example, after inserting IP option data in an IP
	  header to make PML able to recognize the IP option fields.

  void pdu_insert(pdesc, int prid)
	- Insert a new header/trailer with of type 'prid' into the
	  packet after the header and before the trailer for the PDU
	  that 'pdesc' identifies.  This may be 'pkt' to have the new
	  PDU encapsulate the entire packet.  This function inserts new
	  space for the header and trailer.  It also causes the header
	  in pdesc to change its "next protocol" field (e.g. ip.proto
	  or eth.etype) to correctly identify the new header and
	  it adjusts that PDU's checksum accordingly.  This intrinsic
	  does not adjust length or checksum fields (outside of
	  the adjustment for the changed "next protocol" field.

  void pdu_delete(pdesc)
	- Remove the PDU from the packet clearing cutting out its header
	  and trailer data from the packet.  This function also adjusts
	  the "next protocol" field of the immediately enclosing PDU
	  (if any) to point to the PDU that the 'pdesc' PDU enclosed.
	  It correspondingly adjusts the enclosing PDU's checksum if
	  applicable.  This intrinsic does not adjust length or
	  checksum fields (outside of the adjustment for the changed
	  "next protocol" field.
	
.fi
.P
.SS "Numeric Operations"
.nf
  int pop(int v)
  	- returns the number of bits set in 'v'

  int log2(int v)
  	- returns the position of the first bit set in 'v' or -1 if v
	  == 0.

  int min(int x, int y)
  	- returns the minimum of x and y

  int max(int x, int y)
  	- returns the maximum of x and y
.fi
.P
.SS "Packet Metadata Intrinsics"
Per packet metadata that may or may not be present in a given packet.
If the data is not present the meta_get_* function returns -1.
Similarly, setting the metadata to -1 removes the tag rather than 
setting it.
.P
.nf
  int meta_get_ts_sec(int pnum)
  int meta_get_ts_nsec(int pnum)
  	- get the timestamp in seconds/nano-seconds for packet 'pnum'

  void meta_set_ts(int pnum, int sec, int nsec)
  	- set the timestamp for packet 'pnum'

  int meta_get_presnap(int pnum)
  	- get the pre-snapped packet length for packet 'pnum'

  void meta_set_presnap(int pnum, int len)
  	- set the pre-snapped packet length for packet 'pnum' to 'len'

  int meta_get_inport(int pnum)
  	- get the input port for packet 'pnum'.

  void meta_set_inport(int pnum, int port)
  	- set the input port for packet 'pnum' to 'port'.

  int meta_get_outport(pnum)
  	- get the output port for packet 'pnum'.

  void meta_set_outport(pnum, port)
  	- set the output port for packet 'pnum' to 'port'.

  int meta_get_flowid(int pnum)
  	- get the flow identifier of packet 'pnum'.
  	
  void meta_set_flowid(int pnum, int id)
  	- set the flow identifier of packet 'pnum' to 'id'.

  int meta_get_class(int pnum)
  	- get the traffic class of packet 'pnum'.

  void meta_set_class(int pnum, int tc)
  	- set the traffic class of packet 'pnum' to 'tc'.

  int meta_get_seq(int pnum)
  	- get the packet sequence number of packet 'pnum'.

  void meta_set_seq(int pnum, int seq)
  	- set the packet sequence number of packet 'pnum' to 'seq'.
.fi
.P
The following metadata manipulation functions are also available and allow
more fine-grained control over metadata.  But they are also, therefore,
more dangerous and can break things more easily.
.nf
  int  meta_has(pnum, type)
        - Return whether the packet has a tag of type 'type'.

  void meta_add(pnum, type)
	- Add an xpkt tag of type 'type':  limited to timestamp,
	  snapinfo, iniface, outiface, flow, class, seq, 
	  appinfo (0 extra words).

  void meta_add_info(pnum, len)
	- Add an xpkt tag of type XPKT_TAG_APPINFO of length 'len'
	  in packet pnum;

  void meta_rem(pnum, type)
	- Remove the first tag of type 'type'

  int  meta_rd8(pnum, type, off)
	- read 1 byte from a tag at offset 'off'

  int  meta_rd16(pnum, type, off)
	- read 2 bytes from a tag at offset 'off'

  int  meta_rd32(pnum, type, off)
	- read 4 bytes from a tag at offset 'off'

  void meta_wr8(pnum, type, off, val)
	- write 1 byte 'val' from a tag at offset 'off'.  
	  off must be >= 2

  void meta_wr16(pnum, type, off, val)
	- write 2 bytes 'val' from a tag at offset 'off'.
	  off must be >= 2

  void meta_wr32(pnum, type, off, val)
	- write 4 bytes 'val' from a tag at offset 'off'.
	  off must be >= 2

.fi
.P
.SS "Miscellaneous"
.nf
  void exit(int status) 
  	- abort program with exit status 'status'.
.fi
.P
.SS "OPTIMIZATION"
.P
The PML compiler has basic optimization support built in.  It
automatically attempts to use constant propagation to simplify
expressions whose values it can determine at compile time.  An
expression is a 'constant expression' if it is:
.IP "*"
a literal value
.IP "*"
a const
.IP "*"
a binary or unary operator whose operands are constant expressions
.IP "*"
a 'parameter-constant inline macro' all of whose arguments are constant
expressions.
.P
A 'parameter-constant inline macro' is an inline macro whose expression
body would be a constant expression if all of the parameters were
constant.
.P
Assume the following declarations:
.P
.nf
	inline double(int x) { 2 * x }
	inline somefunc(int x, int y) { (2 * x) % y }
	inline isHTTP() { tcp and tcp.dport == 80 or tcp.sport == 80 }
	const A = 5;
	int X;
.fi
.P
Then, the following are constant expression:
.P
.nf
	3
	3 + 5
	3 & 5 * 18
	A / 3
	double(3)
	double(A * 5)
	somefunc(double(3), somefunc(8 * 4 / 2, A))
.fi
.P
The following are not constant expressoins:
.P
.nf
	X
	double(X)
	tcp
	isHTTP()
	$(2)ip
.fi
.P
The inline macros 'double' and 'somefunc' above are parameter-constant
inline macros, but isHTTP is not.  A PML program may assign any constant
expression to a 'const'.
.P
.SH EXAMPLES
Print "Hello World":
.nf

	pml -e "BEGIN { print "Hello World\\n"; }"

.fi
Drop the first 5 packets:
.nf

	pml -e "int count = 0; 
		{ count = count + 1; }
		?- count <= 5 -? { drop; }" 
	    infile.xpkt outfile.xpkt

.fi
Filter out non-ICMP packets:
.nf

	pml -e "?- not icmp -? { drop; }" infile.xpkt outfile.xpkt

.fi
Compile a PML program and run it using nvmpf:
.nf

	pml -f program.pml -c program.nprg
	nvmpf program.nprg infile.xpkt outfile.xpkt
	
.fi
Generate a TCP packet:
.nf

	pml -e "str payload = "Hello World";
		BEGIN {
                    pkt_new(0, str_len(&payload));
                    pdu_insert(pkt, @tcp);
                    pdu_insert(pkt, @ip);
                    pdu_insert(pkt, @eth);
                    tcp.payload = payload;
                    fix_lens(0);
                    fix_csums(0);
		    send;
		}" > tcppacket.xpkt

.fi
Generate a TCP packet using standard library functions:
.nf

        pml -ie "BEGIN { mk_tcp();
                         pkt_splice(tcp.payload, "Hello World");
                         fix(); send; }" > tcppacket.xpkt

.fi
See also the various scripts that come with the ONICS distribution 
such as the *wrap scripts, pcount(1), pfind(1), tcpsess(1).
.SH AVAILABILITY
This utility should be available on all supported ONICS platforms.
.P
.SH AUTHOR
Christopher A. Telfer <ctelfer@gmail.com>
.P
.SH "SEE ALSO"
nvmas(1), nvmpf(1), onics_proto(7)
